

[TOC]



# ä¹±ä¸ƒå…«ç³Ÿ

## è¯­æ³•

```cpp
to_string//è½¬æ¢æˆå­—ç¬¦ä¸²
stroll //è½¬åŒ–æˆæ•°å­—
//setç”¨æ³•
st.insert(x)		//stä¸­æ’å…¥ä¸€ä¸ªå…ƒç´ x
st.size()		//è¿”å›é›†åˆsetä¸­å…ƒç´ çš„ä¸ªæ•°
st.begin()		//seté›†åˆèµ·å§‹åœ°å€
st.end()		//seté›†åˆç»“æŸçš„åœ°å€
set<Type>::iterator it; //å®šä¹‰ä¸€ä¸ªå¯¹åº”ç±»å‹çš„è¿­ä»£å™¨  æ¥éå†set
setéå†ï¼šfor(auto it = set.begin();auto != set.end(),it++)
set.find(x)æ‰¾ä¸åˆ°å°±è¿”å›st.end();
//mapç”¨æ³•
map<char, int> q;
q.insert(pair<int, string>(111, "kk"));
éå†map
for(pair<char,int> x:q)
{
    cout<<x.first<<' '<<x.second<<'\n';
}
substr(0,i)è¾“å‡º(0,i)çš„å­ä¸²
```

## æ±‚ä¸€ä¸ªæ•°äºŒè¿›åˆ¶1çš„ä¸ªæ•°

```CPP
void count(int m){
    int tmp = 0;
    while(m > 0){
        tmp++;
        m &= (m - 1);
    }
}
```

å½“åç¼€å’Œä¸å¥½ç»´æŠ¤çš„æ—¶å€™ï¼Œè€ƒè™‘åç¼€å’Œç­‰äºæ€»å’Œå‡å»å‰ç¼€å’Œï¼Œè½¬æ¢æˆæ€»å’Œå‡å‰ç¼€å’Œ

## å¤„ç†å‘ä¸Šå–æ•´

$è¦æ±‚a/bå‘ä¸Šå–æ•´ï¼Œåˆ™å¯ä»¥ç”¨(a + b - 1)/bè¡¨ç¤º||ç”¨ceil()$

# å¿«è¯»å¿«å†™

```cpp
inline int read()
{
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0' && ch<='9')
        x=x*10+ch-'0',ch=getchar();
    return x*f;
}
void write(int x)
{
    if(x<0)
        putchar('-'),x=-x;
    if(x>9)
        write(x/10);
    putchar(x%10+'0');
    return;
}
```

# äºŒåˆ†

### æœ€å¤§åŒ–æŸ¥æ‰¾ï¼ˆæŸ¥æ‰¾ç¬¬ä¸€ä¸ª<=qçš„æ•°çš„ä¸‹æ ‡ï¼‰

```cpp
#include <bits/stdc++.h>
using namespace std;
int find(int q){
    int l = 0,r = n + 1;
    while(l + 1 < r){
        int mid =l + (r - l) / 2;
        if(a[mid] <= q) l = mid;
        else r= mid;
    }
    return l;
}
lowerbound(begin,end,value) //æ±‚çš„æ˜¯ç¬¬ä¸€ä¸ªå¤§äºç­‰äº
upperbound(begin,end,value) //æ±‚çš„æ˜¯ç¬¬ä¸€ä¸ªå¤§äº
```

### æœ€å°åŒ–æŸ¥æ‰¾(æŸ¥æ‰¾ç¬¬ä¸€ä¸ª>=qçš„æ•°çš„ä¸‹æ ‡)

```cpp
int find(int q){
    int l = 0,r = n + 1;
    while(l + 1 < r){
        int mid =l + (r - l) / 2;
        if(a[mid] >= q) r = mid;
        else l= mid;
    }
    return r;
}
```

## äºŒåˆ†ç­”æ¡ˆ

```cpp
bool check(){

}//ç”¨æ¥åˆ¤æ–­ç­”æ¡ˆæ˜¯å¦å¯è¡Œ
int l = 1,r = MAXN,mid = (l + r) >> 1;
int c;
while(l <= r){ //äºŒåˆ†æŸ¥æ‰¾
	c = check(mid);
    if(c){
        r = mid - 1;
        mid = (l + r) >> 1;
    }else{
        l = mid + 1;
        mid = (l + r) >> 1;
    }
}
```

# æ•°å­¦

## ä½è¿ç®—

### æ¶ˆå»xæœ€åä¸€ä½çš„1

```cpp
x&(x-1)
```

æ¯”å¦‚: åè¿›åˆ¶æ•°`10`çš„äºŒè¿›åˆ¶ä¸º`1010`,`9`çš„äºŒè¿›åˆ¶æ•°ä¸º`1001`,é‚£ä¹ˆ`(1010)&(1001)=1000`ï¼Œç°åœ¨`10`çš„äºŒè¿›åˆ¶ä¸­æœ€åä¸€ä½çš„`1`å·²ç»è¢«æ¶ˆå»

ç”¨é€”:

1. **å¯ä»¥ç”¨æ¥æ£€æµ‹ä¸€ä¸ªæ•°æ˜¯ä¸æ˜¯2çš„å¹‚æ¬¡ã€‚**

   å¦‚æœä¸€ä¸ªæ•°`x`æ˜¯2çš„å¹‚æ¬¡ï¼Œé‚£ä¹ˆ`x>0`ä¸”`x`çš„äºŒè¿›åˆ¶ä¸­åªæœ‰ä¸€ä¸ª1,æ‰€ä»¥ç”¨`x&(x-1)`æŠŠ1æ¶ˆå»ï¼Œåº”è¯¥è¿”å›`0`ï¼Œå¦‚æœè¿”å›äº†é0å€¼ï¼Œè¯æ˜ä¸æ˜¯2çš„å¹‚æ¬¡

2. **è®¡ç®—ä¸€ä¸ªæ•´æ•°äºŒè¿›åˆ¶ä¸­1çš„ä¸ªæ•°**

   å› ä¸º1å¯ä»¥ä¸æ–­çš„é€šè¿‡`x&(x-1)`è¿™ä¸ªæ“ä½œæ¶ˆå»ï¼Œæ‰€ä»¥å½“æœ€åçš„å€¼å˜æˆ0çš„æ—¶å€™ï¼Œä¹Ÿå°±æ±‚å‡ºäº†äºŒè¿›åˆ¶ä¸­1çš„ä¸ªæ•°

3. **å¦‚æœå°†æ•´æ•°`A`è½¬æ¢æˆæ•´æ•°`B`,éœ€è¦æ”¹å˜å¤šå°‘ä¸ªæ¯”ç‰¹ä½.**

   æ€è€ƒå°†æ•´æ•°Aè½¬æ¢ä¸ºBï¼Œå¦‚æœAå’ŒBåœ¨ç¬¬iï¼ˆ0<=i<32ï¼‰ä¸ªä½ä¸Šç›¸ç­‰ï¼Œåˆ™ä¸éœ€è¦æ”¹å˜è¿™ä¸ªBITä½ï¼Œå¦‚æœåœ¨ç¬¬iä½ä¸Šä¸ç›¸ç­‰ï¼Œåˆ™éœ€è¦æ”¹å˜è¿™ä¸ªBITä½ã€‚æ‰€ä»¥é—®é¢˜è½¬åŒ–ä¸ºäº†Aå’ŒBæœ‰å¤šå°‘ä¸ªBITä½ä¸ç›¸åŒã€‚è”æƒ³åˆ°ä½è¿ç®—æœ‰ä¸€ä¸ªå¼‚æˆ–æ“ä½œï¼Œç›¸åŒä¸º0ï¼Œç›¸å¼‚ä¸º1ï¼Œæ‰€ä»¥é—®é¢˜è½¬å˜æˆäº†è®¡ç®—**Aå¼‚æˆ–Bä¹‹åè¿™ä¸ªæ•°ä¸­1çš„ä¸ªæ•°**


å…¶ä»–å¸¸ç”¨æ“ä½œ:

| åŠŸèƒ½                  | ç¤ºä¾‹                   | ä½è¿ç®—                  |
| --------------------- | ---------------------- | ----------------------- |
| å»æ‰æœ€åä¸€ä½          | (101101->10110)        | x shr 1                 |
| åœ¨æœ€ååŠ ä¸€ä¸ª0         | (101101->1011010)      | x shl 1                 |
| åœ¨æœ€ååŠ ä¸€ä¸ª1         | (101101->1011011)      | x shl 1+1               |
| æŠŠæœ€åä¸€ä½å˜æˆ1       | (101100->101101)       | x or 1                  |
| æŠŠæœ€åä¸€ä½å˜æˆ0       | (101101->101100)       | x or 1-1                |
| æœ€åä¸€ä½å–å          | (101101->101100)       | x xor 1                 |
| æŠŠå³æ•°ç¬¬kä½å˜æˆ1      | (101001->101101,k=3)   | x or (1 shl (k-1))      |
| æŠŠå³æ•°ç¬¬kä½å˜æˆ0      | (101101->101001,k=3)   | x and not (1 shl (k-1)) |
| å³æ•°ç¬¬kä½å–å         | (101001->101101,k=3)   | x xor (1 shl (k-1))     |
| å–æœ«ä¸‰ä½              | (1101101->101)         | x and 7                 |
| å–æœ«kä½               | (1101101->1101,k=5)    | x and (1 shl k-1)       |
| å–å³æ•°ç¬¬kä½           | (1101101->1,k=4)       | x shr (k-1) and 1       |
| æŠŠæœ«kä½å˜æˆ1          | (101001->101111,k=4)   | x or (1 shl k-1)        |
| æœ«kä½å–å             | (101001->100110,k=4)   | x xor (1 shl k-1)       |
| æŠŠå³è¾¹è¿ç»­çš„1å˜æˆ0    | (100101111->100100000) | x and (x+1)             |
| æŠŠå³èµ·ç¬¬ä¸€ä¸ª0å˜æˆ1    | (100101111->100111111) | x or (x+1)              |
| æŠŠå³è¾¹è¿ç»­çš„0å˜æˆ1    | (11011000->11011111)   | x or (x-1)              |
| å–å³è¾¹è¿ç»­çš„1         | (100101111->1111)      | (x xor (x+1)) shr 1     |
| å»æ‰å³èµ·ç¬¬ä¸€ä¸ª1çš„å·¦è¾¹ | (100101000->1000)      | x and (x xor (x-1))     |

### åˆ©ç”¨äºŒè¿›åˆ¶æ¥æšä¸¾å­é›†

å‡è®¾æˆ‘ä»¬ç°åœ¨æœ‰5ä¸ªå°çƒï¼Œä¸Šé¢åˆ†åˆ«æ ‡å·äº†`0,1,2,3,4`ä»£è¡¨è¿™äº›å°çƒçš„æƒå€¼,ç°åœ¨è¦åƒä½ æ±‚å‡ºè¿™äº›å°çƒçš„æƒå€¼å¯ä»¥ç»„æˆçš„æ‰€æœ‰æƒ…å†µã€‚

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int n=5;//5ä¸ªå°çƒ
    for(int i=0; i<(1<<n); i++) //ä»0ï½2^5-1ä¸ªçŠ¶æ€
    {
        for(int j=0; j<n; j++) //éå†äºŒè¿›åˆ¶çš„æ¯ä¸€ä½
        {
            if(i&(1<<j))//åˆ¤æ–­äºŒè¿›åˆ¶ç¬¬jä½æ˜¯å¦å­˜åœ¨
            {
                printf("%d ",j);//å¦‚æœå­˜åœ¨è¾“å‡ºç¬¬jä¸ªå…ƒç´ 
            }
        }
        printf("\n");
    }
    return 0;
}
```

### å¼‚æˆ–æ“ä½œ

å¼‚æˆ–çš„æ€§è´¨:

```cpp
x^x=0;
x^0=x;
```

ç”¨é€”:

1. **æ•°ç»„ä¸­ï¼Œåªæœ‰ä¸€ä¸ªæ•°å‡ºç°ä¸€æ¬¡ï¼Œå‰©ä¸‹éƒ½å‡ºç°ä¸¤æ¬¡ï¼Œæ‰¾å‡ºå‡ºç°ä¸€æ¬¡çš„æ•°**

   å› ä¸ºå‰©ä¸‹çš„éƒ½å‡ºç°äº†ä¸¤æ¬¡ï¼Œé‚£ä¹ˆå¼‚æˆ–å€¼è‚¯å®šä¸º0ï¼Œæ‰€ä»¥æŠŠæ‰€æœ‰çš„æ•°å¼‚æˆ–èµ·æ¥å¾—åˆ°çš„å€¼å°±æ˜¯é‚£ä¸ªæ•°ï¼Œå¯ä»¥åšä¸€ä¸‹`nyoj-528`æ‰¾çƒå·(ä¸‰)

2. **ä¸ªæ²¡æœ‰æ¸¸æ ‡çš„å¤©å¹³ï¼Œå’Œnä¸ªç§¤ç £ï¼Œmä¸ªè¯¢é—®ï¼Œ æ¯æ¬¡ä¸€ä¸ªkï¼Œé—®å¯å¦ç§¤å‡ºkè¿™ä¸ªé‡é‡ã€‚ç§¤ç £å¯ä»¥æ”¾ä¸¤è¾¹ã€‚**

   bitsetä¿å­˜çŠ¶æ€ï¼Œç”¨ç§»ä½æ“ä½œæ¥è½¬ç§»ã€‚

   ```c++
   #include <bits/stdc++.h>
   using namespace std;
   const int offset = 2005;
   int w[22];
   
   int main()
   {
       int T;
       scanf("%d", &T);
       while(T--)
       {
           int n;
           scanf("%d", &n);
           for(int i = 0; i < n; i++) scanf("%d", &w[i]);
           bitset <4005> f;
           f[offset] = 1;
           for(int i = 0; i < n; i++){
               f = f | (f << w[i]) | (f >> w[i]);
           }
           int q, k;
           scanf("%d", &q);
           while(q--){
               scanf("%d", &k);
               if(f[offset - k] || f[offset + k]) puts("YES");
               else puts("NO");
           }
       }
       return 0;
   }
   ```

3. å¾…è¡¥å……ã€‚

   

## è¡Œåˆ—å¼è®¡ç®—

```cpp
int det(int a[N][N], int n) {
    int res = 0;
    if (n == 1) {
        return a[0][0];
    } else {
        for (int j = 0; j < n; j++) {
            int t[N][N];
            for (int i = 1; i < n; i++) {
                int k = 0;
                for (int p = 0; p < n; p++) {
                    if (p == j) {
                        continue;
                    }
                    t[i - 1][k++] = a[i][p];
                }
            }
            res += ((j % 2 == 1) ? -1 : 1) * a[0][j] * det(t, n - 1);
        }
    }
    return res;
}
```

## æ¬§æ‹‰ç­›

```cpp
const int N=1e8;
int primes[N],cnt;  //  å­˜æ”¾è´¨æ•°
bool st[N];  //  å½“å‰æ•°æ˜¯å¦è¢«ç­›
 
int minp[N];  //  ä¿å­˜æœ€å°è´¨å› å­
 
int get_primes(int n)  //  æ¬§æ‹‰ç­›  O(n)
{
    for(int i=2;i<=n;i++)
    {
        if(!st[i])  //  è‹¥iæ²¡è¢«ç­›å»  æ­¤æ—¶iå¿…ä¸ºè´¨æ•°
        {
            minp[i]=i;  //  içš„æœ€å°çš„è´¨å› å­ä¸ºi
            primes[cnt++]=i;  //  å°†iä¿å­˜åœ¨primesæ•°ç»„ä¸­  cntå¾€åç§»åŠ¨ä¸€ä½
        }
        for(int j=0;i*primes[j]<=n;j++)
        {
            int t=primes[j]*i;  //  å¾—åˆ°è´¨æ•°çš„å€æ•°
            st[t] = true;  //  è´¨æ•°çš„å€æ•°è¢«ç­›å»
            minp[t]=primes[j];  //  è´¨æ•°çš„å€æ•°æœ€å°çš„è´¨å› å­å°±æ˜¯è¯¥è´¨æ•°
            if(i%primes[j]==0) break;  
            //  è‹¥iæ˜¯ä¹‹å‰ç´ æ•°çš„å€æ•°  
            //  è¯´æ˜è¿™ä¸ªå€æ•°ä¼šåœ¨åé¢çš„å¾ªç¯å†…è¢«ç­›å»  
            //  æ²¡æœ‰å¿…è¦ç»§ç»­å¾ªç¯äº†
        }
    }
}
```

## é€†å…ƒ

åŠ æ³•ä¸­$a$å…ƒç´ çš„é€†å…ƒä¸º-a,åœ¨ä¹˜æ³•è¿ç®—ä¸­açš„é€†å…ƒä¸º$a^-1$

é€†å…ƒå¯ä»¥ç”¨ä¹˜æ³•ä»£æ›¿é™¤æ³•å®ç°é™¤æ³•æ„ä¹‰çš„å–æ¨¡è¿ç®—

![img](https://img2018.cnblogs.com/blog/1749451/201908/1749451-20190823221501534-1732484007.png)

### é€’æ¨æ±‚é€†å…ƒ

```cpp
int ans[N];
void pre(int n)
{
	int ans[1]=1;
	for(int i=2;i<=n;i++){
	ans[i]=(mod-mod/i)*ans[mod%i]%mod;
}
```

### å¿«é€Ÿå¹‚æ±‚é€†å…ƒ

```cpp
ans = qpow(a,p - 2,p);
```

## é¸½å·¢åŸç†

å¦‚æœè¦æŠŠn + 1ä¸ªç‰©ä½“æ”¾è¿›nä¸ªç›’å­ï¼Œé‚£ä¹ˆè‡³å°‘æœ‰ä¸€ä¸ªç›’å­åŒ…å«ä¸¤ä¸ªæˆ–æ›´å¤šçš„ç‰©ä½“

### åŠ å¼ºç‰ˆ

è®¾$q_1,q_2,q_3,q_4.......q_n$ä¸ºæ­£æ•´æ•°,å¦‚æœå°†$q_1,q_2,q_3,q_4......q_n - n + 1$ä¸ªç‰©ä½“æ”¾å…¥nä¸ªç›’å­å†…ï¼Œé‚£ä¹ˆæˆ–è€…ç¬¬ä¸€ä¸ªç›’å­å†…è‡³å°‘å«æœ‰$q_1$ä¸ªç‰©ä½“æˆ–è€…ç¬¬äºŒä¸ªç›’å­å†…è‡³å°‘å«æœ‰$q_2$ä¸ªç‰©ä½“..........ç¬¬nä¸ªç›’å­å†…è‡³å°‘å«æœ‰$q_n$ä¸ªç‰©ä½“ã€‚



## ç»„åˆæ•°

### äºŒé¡¹å¼å®šç†

$(x + y)^n = \sum_{i = 0}^{n} \dbinom{n}{i} x^{n-i}*y^i$å…¶ä¸­$\dbinom{n}{m}$ = $n!/(i!*(n - 1)!)$

### é€’æ¨æ³•

```cpp
const int N = 2010, mod = 1e9 + 7;

int C[N][N];

void init(){
	for(int i = 0; i < N; i++) C[i][0] = C[i][i] = 1;
	for(int i = 1; i < N; i++)
		for(int j = 1; j < i; j++)
			C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;
}
```

###  å¿«é€Ÿå¹‚

```cpp
int ksm(int x,int y)
{
	x%=mod;
		int num=1;
		while(y){
		if(y&1)num=num*x%mod;
		y>>=1;
		x=x*x%mod;
	}
	return num;
}
int jie[N],nijie[N];
void pre(int n)
{
	jie[0]=1;
	for(int i=1;i<=n;i++){
		jie[i]=jie[i-1]*i%mod;
	}
	nijie[n]=ksm(jie[n],mod-2);
	for(int i=n;i>=1;i--){
		nijie[i-1]=nijie[i]*i%mod;
	}
}
int C(int n,int m)
{
	if(m<0||n<m)return 0;
	return jie[n]*nijie[m]%mod*nijie[n-m]%mod;
}
```

## æ¬§æ‹‰å‡½æ•°

$æ¬§æ‹‰å‡½æ•°Ï†(n)è¡¨ç¤º1\sim nä¸­æ‰€æœ‰ä¸näº’è´¨çš„æ•°ã€‚æ¯”å¦‚1\sim8ä¸­ä¸8äº’è´¨çš„æ•°æœ‰1,3,5,7ï¼Œæ‰€ä»¥Ï†(8)=4$ã€‚

$å…¬å¼1ï¼šå¦‚æœpæ˜¯ç´ æ•°ï¼Œåˆ™Ï†(p) = 1,å…¬å¼2ï¼šå¦‚æœgcdï¼ˆa,bï¼‰ = 1ï¼Œåˆ™Ï†(a*b) = Ï†(a)*Ï†(b)$

$n = p_1^{k1}*p_2^{k2}*p_3^{k3}*......p_r^{kr}ä¸”pä¸ºè´¨æ•°,å› æ­¤$

$Ï†(p^k) = p^k - p^{k - 1}$å› ä¸ºpæ˜¯è´¨æ•°ï¼Œæ‰€ä»¥$1$~$p^k$ä¸­é—´é™¤äº†pçš„å€æ•°ä¹‹å¤–æ‰€æœ‰æ•°éƒ½ä¸päº’è´¨ï¼Œè€Œpçš„å€æ•°çš„ä¸ªæ•°æ˜¯$p^k/p$

$æ¬§æ‹‰å‡½æ•°çš„é€šé¡¹å…¬å¼Ï†(n) = n*(1 - 1/p_1)*(1-1/p_2)*(1 - 1/p_3)......*(1-1/p_r)$ 

1.å¦‚æœåªæ±‚Ï†(n)ï¼Œå”¯ä¸€åˆ†è§£ é‚£ä¹ˆæˆ‘ä»¬å°±ç›´æ¥å°†nå”¯ä¸€åˆ†è§£å¤„ç†å‡ºæ¯ä¸€ä¸ªnçš„ç´ æ•°ï¼Œç„¶åç”¨é€šé¡¹å…¬å¼å°±è¡Œäº†ã€‚ æ•ˆç‡ï¼šO(âˆšn) 

```cpp
#include <cmath>
int euler_phi(int n) {
  int ans = n;
  for (int i = 2; i * i <= n; i++)
    if (n % i == 0) {
      ans = ans / i * (i - 1);
      while (n % i == 0) n /= i;
    }
  if (n > 1) ans = ans / n * (n - 1);
  return ans;
}
```

2.å¦‚æœè¦æ±‚ä¸€ä¸ªåŒºåŸŸå†…çš„æ¬§æ‹‰å‡½æ•°$Ï†(1 - n)$ç”¨å”¯ä¸€åˆ†è§£å°±å¤ªæ…¢äº†ï¼Œç”¨åˆ°ç§¯æ€§å…¬å¼å»åšåˆ†è§£

```cpp
vector<int> pri;
bool not_prime[N];
int phi[N];

void pre(int n) {
  phi[1] = 1;
  for (int i = 2; i <= n; i++) {
    if (!not_prime[i]) {
      pri.push_back(i);
      phi[i] = i - 1;
    }
    for (int pri_j : pri) {
      if (i * pri_j > n) break;
      not_prime[i * pri_j] = true;
      if (i % pri_j == 0) {
        phi[i * pri_j] = phi[i] * pri_j;
        break;
      }
      phi[i * pri_j] = phi[i] * phi[pri_j];
    }
  }
}
```

## æ¬§æ‹‰å®šç†

è‹¥æ­£æ•´æ•°a,näº’è´¨ï¼Œåˆ™æœ‰$a^{Ï†(x)}\equiv 1 \pmod n$

å¦‚$m = 10,a = 3æ—¶ï¼ŒÏ†(10) = 4,3^4 = 81 \equiv 1\pmod n$

## è«æ¯”ä¹Œæ–¯å‡½æ•°

#### åæ¼”ç»“è®º

$[gcd(i,j) = 1] = \sum\limits_{d/gcd(i,j)}u(d)$

##  ç´ æ•°æµ‹è¯•ä¸å› å¼åˆ†è§£ï¼ˆMiller-Rabin & Pollard-Rhoï¼‰

isprimeå‡½æ•°åˆ¤æ–­ç´ æ•°ï¼ŒPollard-Rhoåœ¨factorizeä¸­åœ¨æ•°ç»„é‡Œå­˜å‚¨å› å­

```cpp
ll mul(ll a, ll b, ll m) {
    return static_cast<__int128>(a) * b % m;
}
ll power(ll a, ll b, ll m) {
    ll res = 1 % m;
    for (; b; b >>= 1, a = mul(a, a, m))
        if (b & 1)
            res = mul(res, a, m);
    return res;
}
bool isprime(ll n) {
    if (n < 2)
        return false;
    static constexpr int A[] = {2, 3, 5, 7, 11, 13, 17, 19, 23};
    int s = __builtin_ctzll(n - 1);
    ll d = (n - 1) >> s;
    for (auto a : A) {
        if (a == n)
            return true;
        ll x = power(a, d, n);
        if (x == 1 || x == n - 1)
            continue;
        bool ok = false;
        for (int i = 0; i < s - 1; ++i) {
            x = mul(x, x, n);
            if (x == n - 1) {
                ok = true;
                break;
            }
        }
        if (!ok)
            return false;
    }
    return true;
}
std::vector<ll> factorize(ll n) {
    std::vector<ll> p;
    std::function<void(ll)> f = [&](ll n) {
        if (n <= 10000) {
            for (int i = 2; i * i <= n; ++i)
                for (; n % i == 0; n /= i)
                    p.push_back(i);
            if (n > 1)
                p.push_back(n);
            return;
        }
        if (isprime(n)) {
            p.push_back(n);
            return;
        }
        auto g = [&](ll x) {
            return (mul(x, x, n) + 1) % n;
        };
        ll x0 = 2;
        while (true) {
            ll x = x0,ll y = x0,ll d = 1;
            ll power = 1, lam = 0;
            ll v = 1;
            while (d == 1) {
                y = g(y);
                ++lam;
                v = mul(v, std::abs(x - y), n);
                if (lam % 127 == 0) {
                    d = std::gcd(v, n);
                    v = 1;
                }
                if (power == lam) {
                    x = y;
                    power *= 2;
                    lam = 0;
                    d = std::gcd(v, n);
                    v = 1;
                }
            }
            if (d != n) {
                f(d);
                f(n / d);
                return;
            }
            ++x0;
        }
    };
    f(n);
    std::sort(p.begin(), p.end());
    return p;
}

```





# æœç´¢

## DFS

æŠŠæ ¹èŠ‚ç‚¹æ”¾è¿›æ ˆé‡Œ
å–å‡ºä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¿›è¡Œå¤„ç†
å°†æ­¤èŠ‚ç‚¹çš„å­èŠ‚ç‚¹æ”¾å…¥æ ˆï¼ˆæ²¡æœ‰å­èŠ‚ç‚¹å°±ä¸æ”¾ï¼‰
åˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©ºã€‚å¦‚æœéç©ºï¼Œè¿”å›ç¬¬2æ­¥ï¼›å¦‚æœä¸ºç©ºï¼Œç»“æŸã€‚

 ```cpp
int maxn = 0x3f;
vector<int> e[maxn]; //è¿æ¥å…³ç³»
bool vis[maxn];
void dfs(int u){ 
    if(ç»“æŸæ¡ä»¶) return;
    vis[u] = 1; //æ ‡è®°å·²ç»æœç´¢è¿‡
    for (int i = 0 ;i < e[u] ;i++){
        int v = e[u][i];
        if(vis[v]) continue;// å·²ç»æœç´¢è¿‡äº†,å‰ªæ
        dfs(v);//ä¸‹ä¸€æ­¥æœç´¢
    }
    return;
}
 ```

## BFS

BFSçš„åŸºæœ¬æ€è·¯æ˜¯ï¼š

æŠŠæ ¹èŠ‚ç‚¹æ”¾è¿›é˜Ÿåˆ—é‡Œ
å–å‡ºä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¿›è¡Œå¤„ç†
å°†æ­¤èŠ‚ç‚¹çš„å­èŠ‚ç‚¹æ”¾å…¥é˜Ÿåˆ—ï¼ˆæ²¡æœ‰å­èŠ‚ç‚¹å°±ä¸æ”¾ï¼‰
åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©ºã€‚å¦‚æœéç©ºï¼Œè¿”å›ç¬¬2æ­¥ï¼›å¦‚æœä¸ºç©ºï¼Œç»“æŸã€‚

```cpp
vector<int> e[maxn]; //è¿æ¥å…³ç³»
bool vis[maxn];
void  bfs(int x){
    queue<int> q;
    q.push(x);
    while(!q.empty()){
        int u = q.front();
        q.pop();
        vis[u] = 1;
        for (int i = 1 ; i < e[u] ; i++){
            int v = e[u][i];
            if(vis[v]) continue;
            q.push(v);
        }
    }
}
```

# å¿«é€Ÿå¹‚

```cpp 
int qpow(int a, int n,int mod)
{
    // a==0 && n==0 ç‰¹åˆ¤
    int ans = 1; // n = 0 æ—¶å€™ä¸è¿›å¾ªç¯
    while(n)
    {
        if(n & 1) 
            ans = a * ans%mod;
        a = a * a%mod;
        n >>= 1;
    }
    return ans%mod;
}
```

# å­—ç¬¦ä¸²

## KMP

### 1.æ±‚NEXTæ•°ç»„

```cpp
void get_next(string b,int *next)
{
	int k=-1,j=0;
	next[0]=-1;
	while(j<b.size()) 
	{
		if(k==-1 || b[k]==b[j])
			next[++j]=++k;   //next[j]=next[j-1]+1; 
		else k=next[k];   //kå›æº¯
	}
}
```

### 2.æ±‚æ˜¯å¦åŒ¹é…

```cpp
int KMP(string a,string b,int *next)
{
	int i=0,j=0;
	while(i<a.size())
	{
		if(a[i]==b[j] || j==-1) i++,j++; //ç›¸ç­‰åç§»
		else j=next[j];
		if(j==b.size()) return i-j;
		else if(j>b.size()) return -1; 
	}
}
```

## å­—ç¬¦ä¸²å“ˆå¸Œ

19260817 //å¤§è´¨æ•°

å¤šé¡¹å¼å“ˆå¸Œå‡½æ•°$f(s) = \sum_{i = 1}^ls[i]*b^{l - i}(Mod M)$ å…¶ä¸­$M$æ˜¯ä¸€ä¸ªç´ æ•°

```cpp
using std::string;

const int M = 1e9 + 7;
const int B = 233;

typedef long long ll;

int get_hash(const string& s) {
  int res = 0;
  for (int i = 0; i < s.size(); ++i) {
    res = ((ll)res * B + s[i]) % M;
  }
  return res;
}

bool cmp(const string& s, const string& t) {
  return get_hash(s) == get_hash(t);
}
```

(æ•ˆç‡ä½ä¸‹çš„ç‰ˆæœ¬)

### è¿›åˆ¶å“ˆå¸Œ

è¿›åˆ¶å“ˆå¸Œçš„æ ¸å¿ƒä¾¿æ˜¯**ç»™å‡ºä¸€ä¸ªå›ºå®šè¿›åˆ¶ğ‘ğ‘ğ‘ ğ‘’ï¼Œå°†ä¸€ä¸ªä¸²çš„æ¯ä¸€ä¸ªå…ƒç´ çœ‹åšä¸€ä¸ªè¿›åˆ¶ä½ä¸Šçš„æ•°å­—ï¼Œæ‰€ä»¥è¿™ä¸ªä¸²å°±å¯ä»¥çœ‹åšä¸€ä¸ªğ‘ğ‘ğ‘ ğ‘’è¿›åˆ¶çš„æ•°ï¼Œé‚£ä¹ˆè¿™ä¸ªæ•°å°±æ˜¯è¿™ä¸ªä¸²çš„å“ˆå¸Œå€¼ï¼›åˆ™æˆ‘ä»¬é€šè¿‡æ¯”å¯¹æ¯ä¸ªä¸²çš„çš„å“ˆå¸Œå€¼ï¼Œå³å¯åˆ¤æ–­ä¸¤ä¸ªä¸²æ˜¯å¦ç›¸åŒ**

[LuoguP3370](https://www.luogu.com.cn/problem/P3370)

```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cstdio>
using namespace std;
using LL = long long;
typedef ull unsigned long long
ull base=131;
ull a[10010];
char s[10010];
int n,ans=1;
int prime=233317; 
ull mod=212370440130137957ll;
ull hashe(char s[])
{
 	int len=strlen(s);
 	LL ans=0;
 	for (int i=0;i<len;i++)
 		ans=(ans*base+(ull)s[i])%mod+prime;
 	return ans;
}
int main()
{
 	scanf("%d",&n);
 	for(int i=1;i<=n;i++){
 		scanf("%s",s);
 		a[i]=hashe(s);
 	}
 	sort(a+1,a+n+1);
 	for(int i=1;i<n;i++){
 		if(a[i]!=a[i+1])
 		ans++;
 	}
 	printf("%d",ans);
}
```

## å¤šé‡å“ˆå¸Œ

```cpp
#include<bits/stdc++.h>
#define FAST std::ios::sync_with_stdio(false),std::cin.tie(0),std::cout.tie(0)
using namespace std;
int mod1=20160817;
int mod2=19260817; 
int n,ans=1;
int base=131;
struct node{
	int x,y;
}a[100001];
int hash1(string s){
	int sum=0;
	for(int i=0;i<s.size();i++){
      	sum=base*sum+(int)(s[i]);
      sum%=mod1;
   }
     return sum;
}
int hash2(string s){
     int sum=0;
     for(int i=0;i<s.size();i++){
       	sum=base*sum+(int)(s[i]);
        sum%=mod2;
     }
     return sum;//è¿”å›hashå€¼ 
}
bool sj(node x,node y){
     return x.x<y.x;
}
int main(){
     FAST;//ä¼˜åŒ–è¾“å…¥è¾“å‡º 
     cin>>n;
	 for(int i=1;i<=n;i++){
         string s;//è¾“å…¥å­—ç¬¦ä¸² 
         cin>>s;
         a[i].x=hash1(s);//ç»™å®ƒhashå€¼ 
         a[i].y=hash2(s);
     }
     sort(a+1,a+1+n,sj);//hashå€¼æ’åº 
     for(int i=2;i<=n;i++){
         if(a[i].x!=a[i-1].x||a[i].y!=a[i-1].y)ans++;
     }
     cout<<ans;
}
```

## å­—å…¸æ ‘

```cpp
const int MAXN = 500005;
int next[MAXN][26], cnt; // ç”¨ç±»ä¼¼é“¾å¼å‰å‘æ˜Ÿçš„æ–¹å¼å­˜å›¾ï¼Œnext[i][c]è¡¨ç¤ºiå·ç‚¹æ‰€è¿ã€å­˜å‚¨å­—ç¬¦ä¸ºc+'a'çš„ç‚¹çš„ç¼–å·
void init(){ //åˆå§‹åŒ–
    memset(next, 0, sizeof(next)); // å…¨éƒ¨é‡ç½®ä¸º0ï¼Œè¡¨ç¤ºå½“å‰ç‚¹æ²¡æœ‰å­˜å‚¨å­—ç¬¦
    cnt = 1;
}
void insert(const string &s){	//æ’å…¥å­—ç¬¦ä¸²
    int cur = 1;
    for (auto c : s){
        // å°½å¯èƒ½é‡ç”¨ä¹‹å‰çš„è·¯å¾„ï¼Œå¦‚æœåšä¸åˆ°åˆ™æ–°å»ºèŠ‚ç‚¹
        if (!next[cur][c - 'a']) 
            next[cur][c - 'a'] = ++cnt; 
        cur = next[cur][c - 'a']; // ç»§ç»­å‘ä¸‹
    }
} //å­—å…¸æ ‘å»ºæ ‘
bool find_prefix(const string &s) // æŸ¥æ‰¾æŸä¸ªå‰ç¼€æ˜¯å¦å‡ºç°è¿‡
{
    int cur = 1;
    for (auto c : s)
    {
        // æ²¿ç€å‰ç¼€æ‰€å†³å®šçš„è·¯å¾„å¾€ä¸‹èµ°ï¼Œå¦‚æœä¸­é€”å‘ç°æŸä¸ªèŠ‚ç‚¹ä¸å­˜åœ¨ï¼Œè¯´æ˜å‰ç¼€ä¸å­˜åœ¨
        if (!next[cur][c - 'a'])
            return false;
        cur = next[cur][c - 'a'];
    }
    return true;
}

```



## ACè‡ªåŠ¨æœº



# åŠ¨æ€è§„åˆ’

## çº¿æ€§åŠ¨æ€è§„åˆ’



###  æœ€é•¿å„ç§åºåˆ—

#### æœ´ç´ åšæ³•

```cpp
#include<bits/stdc++.h>
#define ll long long
#define int ll
using namespace std;
const int maxn = 1e6 + 10;
int a[maxn], dp[maxn];
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie();
	cout.tie();
	int n;
	cin>>n;
	for (int i = 1; i <= n; i++) {
		cin>>a[i];
		dp[i] = 1; //æœ¬èº«å°±æ˜¯ä¸€ä¸ªé•¿åº¦ä¸º1çš„å­åˆ— 
	}
	//æœ€é•¿ä¸Šå‡å­åˆ— 
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j < i; j++) {
			if (a[j] < a[i]) {
				dp[i] = max(dp[i], dp[j] + 1);
			}
		} 
	}
	//æœ€é•¿ä¸ä¸‹é™å­åˆ—
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j < i; j++) {
			if (a[j] <= a[i]) {
				dp[i] = max(dp[i], dp[j] + 1);
			}
		} 
	}
	//æœ€é•¿ä¸‹é™å­åˆ—
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j < i; j++) {
			if (a[j] > a[i]) {
				dp[i] = max(dp[i], dp[j] + 1);
			}
		} 
	}
	//æœ€é•¿ä¸ä¸Šå‡å­åˆ—
	for (int i = 1; i <= n; i++) {
 		for (int j = 1; j < i; j++) {
 			if (a[j] >= a[i]) {
 				dp[i] = max(dp[i], dp[j] + 1);
 			}
 		} 
 	}
	return 0;
```

#### äºŒåˆ†ä¼˜åŒ–

```cpp
#include<bits/stdc++.h>
#define ll long long
#define int ll
using namespace std;
const int maxn = 1e6 + 10;
int a[maxn], dp[maxn];
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie();
	cout.tie();
	int n, len;
	cin>>n;
	for (int i = 1; i <= n; i++) {
		cin>>a[i];
	}
	//æœ€é•¿ä¸Šå‡å­åˆ— 
	len = 0; // æœ€å¼€å§‹çš„æœ€é•¿å­åˆ—é•¿åº¦ä¸º0 
	dp[0] = -1e17; //ä¿è¯äº†ç¬¬1ä½çš„æ•°å­—ä¸€å®šèƒ½è‡³å°‘æ”¾åœ¨é•¿åº¦ä¸º0çš„å­åˆ—åè¾¹ 
	for (int i = 1; i <= n; i++) {
		int l = 0, r = len;
		while (l < r) {
			int mid = (l + r + 1) / 2;
			if (dp[mid] <= a[i]) {
				l = mid;
			} else {
				r = mid - 1;
			}
		}
		len = max(len, l + 1);
		dp[l + 1] = a[i]; //ä¸éœ€åˆ¤æ–­äºŒè€…å¤§å° å› ä¸ºè‹¥åŸå…ˆdp[l+1]ä¸ä¸º0 æ˜¯å¿…ç„¶å¤§äºa[i]çš„ 
	}
	cout<<len;//æœ€é•¿å­åˆ—é•¿åº¦ 
	//æœ€é•¿ä¸ä¸‹é™å­åˆ—
	len = 0; // æœ€å¼€å§‹çš„æœ€é•¿å­åˆ—é•¿åº¦ä¸º0 
	dp[0] = -1e17; //ä¿è¯äº†ç¬¬1ä½çš„æ•°å­—ä¸€å®šèƒ½è‡³å°‘æ”¾åœ¨é•¿åº¦ä¸º0çš„å­åˆ—åè¾¹ 
	for (int i = 1; i <= n; i++) {
		int l = 0, r = len;
		while (l < r) {
			int mid = (l + r + 1) / 2;
			if (dp[mid] < a[i]) {
				l = mid;
			} else {
				r = mid - 1;
			}
		}
		len = max(len, l + 1);
		dp[l + 1] = a[i]; //ä¸éœ€åˆ¤æ–­äºŒè€…å¤§å° å› ä¸ºè‹¥åŸå…ˆdp[l+1]ä¸ä¸º0 æ˜¯å¿…ç„¶å¤§äºa[i]çš„ 
	}
	cout<<len;//æœ€é•¿å­åˆ—é•¿åº¦ 
	//æœ€é•¿ä¸‹é™å­åˆ—
	len = 0; // æœ€å¼€å§‹çš„æœ€é•¿å­åˆ—é•¿åº¦ä¸º0 
	dp[0] = 1e17; //ä¿è¯äº†ç¬¬1ä½çš„æ•°å­—ä¸€å®šèƒ½è‡³å°‘æ”¾åœ¨é•¿åº¦ä¸º0çš„å­åˆ—åè¾¹ 
	for (int i = 1; i <= n; i++) {
		int l = 0, r = len;
		while (l < r) {
			int mid = (l + r + 1) / 2;
			if (dp[mid] >= a[i]) {
				l = mid;
			} else {
				r = mid - 1;
			}
		}
		len = max(len, l + 1);
		dp[l + 1] = a[i]; //ä¸éœ€åˆ¤æ–­äºŒè€…å¤§å° å› ä¸ºè‹¥åŸå…ˆdp[l+1]ä¸ä¸º0 æ˜¯å¿…ç„¶å°äºa[i]çš„ 
	}
	cout<<len;//æœ€é•¿å­åˆ—é•¿åº¦ 
	//æœ€é•¿ä¸ä¸Šå‡å­åˆ—
	len = 0; // æœ€å¼€å§‹çš„æœ€é•¿å­åˆ—é•¿åº¦ä¸º0 
	dp[0] = 1e17; //ä¿è¯äº†ç¬¬1ä½çš„æ•°å­—ä¸€å®šèƒ½è‡³å°‘æ”¾åœ¨é•¿åº¦ä¸º0çš„å­åˆ—åè¾¹ 
	for (int i = 1; i <= n; i++) {
		int l = 0, r = len;
		while (l < r) {
			int mid = (l + r + 1) / 2;
			if (dp[mid] > a[i]) {
				l = mid;
			} else {
				r = mid - 1;
			}
		}
		len = max(len, l + 1);
		dp[l + 1] = a[i]; //ä¸éœ€åˆ¤æ–­äºŒè€…å¤§å° å› ä¸ºè‹¥åŸå…ˆdp[l+1]ä¸ä¸º0 æ˜¯å¿…ç„¶å°äºa[i]çš„ 
	}
	cout<<len;//æœ€é•¿å­åˆ—é•¿åº¦ 
	return 0;
```

## èƒŒåŒ…é—®é¢˜

### 01èƒŒåŒ…

ä¸€ä¸ªç‰©å“åªèƒ½å–ä¸€æ¬¡

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 110, M = 1010;
int n, m, v[N], w[N]; // n-ç‰©å“ç§æ•° m-èƒŒåŒ…å®¹ç§¯ v[i]-iå·ç‰©å“çš„ä½“ç§¯ã€w[i]-iå·ç‰©å“çš„ä»·å€¼
int f[M];
int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cin >> m >> n;
	for (int i = 1; i <= n; ++ i) cin >> v[i] >> w[i];
	for (int i = 1; i <= n; ++ i) {
		for (int j = m; j >= v[i]; -- j) { // æ³¨æ„jçš„éå†é¡ºåº
			f[j] = max(f[j], f[j - v[i]] + w[i]);
		}
	}
	cout << f[m] << '\n';
	return 0;
}
```

### å®Œå…¨èƒŒåŒ…

æœ‰æ— æ•°ä¸ªç‰©å“ï¼Œå¯ä»¥ä»»æ„å–

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 1e4, M = 1e7;
ll n, m, v[N], w[N]; // n-ç‰©å“ç§æ•° m-èƒŒåŒ…å®¹ç§¯ v[i]-iå·ç‰©å“çš„ä½“ç§¯ã€w[i]-iå·ç‰©å“çš„ä»·å€¼
ll f[M];
int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cin >> m >> n;
	for (int i = 1; i <= n; ++ i) cin >> v[i] >> w[i];
	for (int i = 1; i <= n; ++ i) {
	for (int j = v[i]; j <= m; ++ j) { // æ³¨æ„jçš„éå†é¡ºåº
			f[j] = max(f[j], f[j - v[i]] + w[i]);
		}
	}
	cout << f[m] << '\n';
	return 0;
}
```

### åˆ†ç»„èƒŒåŒ…

æœ‰â¼€äº›ç‰©å“å’Œâ¼€ä¸ªå®¹ç§¯ä¸º$m$çš„èƒŒåŒ…ï¼ŒæŠŠç‰©å“åˆ†æˆnç»„ï¼Œå…¶ä¸­ç¬¬$i$ç»„å…±$s[i]$ ç§ç‰©å“ï¼Œç¬¬$k$ç§ç‰©å“çš„ä½“ç§¯ä¸º,ä»·å€¼ä¸º$w[i][k]$,

æ¯ç»„ä¸­åªèƒ½é€‰æ‹©â¼€ä¸ªç‰©å“ï¼Œè¦æ±‚ä»$n$ç»„ä¸­é€‰å‡ºè‹¥â¼²ç‰©å“ä½¿å…¶æ€»ä»·å€¼æœ€â¼¤ä¸”æ€»ä½“ç§¯ä¸è¶…è¿‡èƒŒåŒ…å®¹ç§¯ã€‚

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1010, M = 110;
int s[M], v[M][N], w[M][N];
int f[N];
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n, m;
	cin >> m >> n;
	for (int i = 1; i <= n; ++ i) {
	int a, b, c;
	cin >> a >> b >> c;
	++ s[c];
	v[c][s[c]] = a, w[c][s[c]] = b;
	}
	for (int i = 1; i <= n; ++ i)
		for (int j = m; j >= 0; -- j)
			for (int k = 1; k <= s[i]; ++ k)
				if (j >= v[i][k]) f[j] = max(f[j], f[j - v[i][k]] + w[i][k]);
	cout << f[m] << '\n';
	return 0;
}	
```

### å¤šé‡èƒŒåŒ…

æœ‰$n$ç§ç‰©å“å’Œâ¼€ä¸ªå®¹ç§¯ä¸º$m$ çš„èƒŒåŒ…,ç¬¬$i$ç§ç‰©å“çš„ä½“ç§¯ä¸º$v[i]$ ,ä»·å€¼ä¸º$w[i]$ï¼Œå…±$s[i]$ä¸ªï¼Œè¦æ±‚ä»$n$ç§ç‰©å“ä¸­

å–å‡ºè‹¥â¼²ä½¿å…¶æ€»ä»·å€¼æœ€â¼¤ä¸”æ€»ä½“ç§¯ä¸è¶…è¿‡èƒŒåŒ…å®¹ç§¯$m$.

#### æœ´ç´ åšæ³•

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10, M = 4e4 + 10;
int v[N], w[N], s[N], f[M];
int main() {
ios::sync_with_stdio(false);
cin.tie(0);
int n, m;
cin >> n >> m;
	for (int i = 1; i <= n; ++ i) cin >> w[i] >> v[i] >> s[i];
	for (int i = 1; i <= n; ++ i)
		for (int k = 1; k <= s[i]; ++ k)
			for (int j = m; j >= v[i]; -- j)
				f[j] = max(f[j], f[j - v[i]] + w[i]);
	cout << f[m] << '\n';
	return 0;
}
```

#### äºŒè¿›åˆ¶æ‹†åˆ†ä¼˜åŒ–

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=100010;
int n,C,dp[N];
int w[N],c[N],m[N];
int new_n; //â¼†è¿›åˆ¶æ‹†åˆ†åçš„æ–°ç‰©å“æ€»æ•°é‡
int new_w[N],new_c[N],new_m[N]; //â¼†è¿›åˆ¶æ‹†åˆ†åæ–°ç‰©å“
int main(){
	cin >> n >>C;
	for(int i=1;i<=n;i++) cin>>w[i]>>c[i]>>m[i];
	//ä»¥ä¸‹æ˜¯â¼†è¿›åˆ¶æ‹†åˆ†
	int new_n = 0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m[i];j<<=1) { //â¼†è¿›åˆ¶æšä¸¾ï¼š1,2,4...
			m[i]-=j; //å‡å»å·²æ‹†åˆ†çš„
			new_c[++new_n] = j*c[i]; //æ–°ç‰©å“
			new_w[new_n] = j*w[i];
		}
		if(m[i]){ //æœ€åâ¼€ä¸ªæ˜¯ä½™æ•°
			new_c[++new_n] = m[i]*c[i];
			new_w[new_n] = m[i]*w[i];
		}
	}
	//ä»¥ä¸‹æ˜¯æ»šåŠ¨æ•°ç»„ç‰ˆæœ¬çš„0/1èƒŒåŒ…
	for(int i=1;i<=new_n;i++) //æšä¸¾ç‰©å“
	for(int j=C;j>=new_c[i];j--) //æšä¸¾èƒŒåŒ…å®¹é‡
	dp[j] = max(dp[j],dp[j-new_c[i]]+new_w[i]);
	cout << dp[C] << endl;
	return 0;

```

## åŒºé—´dp

åŒºé—´ç±»å‹åŠ¨æ€è§„åˆ’æ˜¯çº¿æ€§åŠ¨æ€è§„åˆ’çš„æ‹“å±•ï¼Œå®ƒåœ¨åˆ†é˜¶æ®µåˆ’åˆ†é—®é¢˜æ—¶ï¼Œä¸é˜¶æ®µä¸­å…ƒç´ å‡ºç°çš„é¡ºåºå’Œç”±å‰ä¸€é˜¶æ®µçš„å“ªäº›å…ƒç´ åˆå¹¶è€Œæ¥æœ‰å¾ˆå¤§çš„å…³ç³».ä¾‹å¦‚$f[i][j] = f[i][k] + f[k + 1][j]$,åŒºé—´ç±»åŠ¨æ€è§„åˆ’çš„ç‰¹ç‚¹ï¼š

- åˆå¹¶ï¼šå³å°†ä¸¤ä¸ªæˆ–å¤šä¸ªéƒ¨åˆ†è¿›è¡Œæ•´åˆã€‚

- ç‰¹å¾ï¼šèƒ½å°†é—®é¢˜åˆ†è§£æˆä¸ºä¸¤ä¸¤åˆå¹¶çš„å½¢å¼ã€‚

- æ±‚è§£ï¼šå¯¹æ•´ä¸ªé—®é¢˜è®¾æœ€ä¼˜å€¼ï¼Œæšä¸¾åˆå¹¶ç‚¹ï¼Œå°†é—®é¢˜åˆ†è§£æˆä¸ºå·¦å³ä¸¤ä¸ªéƒ¨åˆ†ï¼Œæœ€åå°†å·¦å³ä¸¤ä¸ªéƒ¨åˆ†çš„æœ€ä¼˜å€¼è¿›è¡Œåˆå¹¶å¾—åˆ°åŸé—®é¢˜çš„æœ€ä¼˜å€¼ã€‚

  åŒºé—´dpçš„åšæ³•æ¯”è¾ƒå›ºå®šï¼Œå³æšä¸¾**åŒºé—´é•¿åº¦**ï¼Œå†æšä¸¾**å·¦ç«¯ç‚¹**ï¼Œä¹‹åæšä¸¾ç«¯ç‚¹çš„**æ–­ç‚¹**è¿›è¡Œè½¬ç§»

  ä¾‹é¢˜ï¼š[LuoguP1880çŸ³å­åˆå¹¶](https://www.luogu.com.cn/problem/P1880)

  ```cpp
  #include<bits/stdc++.h>
  using std::cin,std::cout,std::deque,std::pair,std::queue,std::vector;
  #define int long long
  #define inf 0x3f3f3f3f
  int qpow(int a, int n,int mod = 1e9 + 7){
      int ans = 1; while(n){if(n & 1){ans = a * ans%mod;}a = a * a%mod;n >>= 1;}return ans%mod;
  }
  // int head[N],cnt;
  // struct edge{
  // 	int to,nxt,val;
  // }e[N];
  // int add(int u,int v){
  // 	e[++cnt].to = v;
  // 	e[cnt].nxt = head[u];
  // 	head[u] = cnt;
  // }
  const int N = 210;
  int a[2*N];
  int dpmax[N][N];
  int dpmin[N][N];
  int sum[N];
  void solve(){
      int n;
      cin >> n;
      for(int i = 1;i <= n;i++){
          cin >> a[i];
          a[i + n] = a[i];
      }
      for(int i = 1;i <= 2*n;i++){
          sum[i] = sum[i - 1] + a[i];
      }
      for(int len = 2;len <= n;len++){
          for(int l = 1;l < 2*n - len + 1;l++){
              int r = len + l - 1;
              dpmin[l][r] = inf,dpmax[l][r] = 0;
              for(int k = l;k <= r;k++){
                  dpmin[l][r] = std::min(dpmin[l][k] + dpmin[k + 1][r],dpmin[l][r]);
                  dpmax[l][r] = std::max(dpmax[l][k] + dpmax[k + 1][r],dpmax[l][r]);
              }
              dpmin[l][r] += sum[r] - sum[l - 1];
              dpmax[l][r] += sum[r] - sum[l - 1];
          }
      }
      int max = 0,min = inf;
      for(int i = 1;i <= n;i++){
          min = std::min(dpmin[i][n + i - 1],min);
          max = std::max(dpmax[i][n + i - 1],max);
      }
      cout << min << '\n' << max << '\n';
  }
  signed main(){
      std::ios::sync_with_stdio(false);
      cin.tie(0);
      int T;
      T = 1;
   	//cin >> T;
      while(T--){
          solve();
      }
  }
  ```

## æ ‘å½¢dp

### ä¸¤ç§æ–¹å‘

- 1.æ ¹->å¶ï¼ˆå¾€å¾€æ˜¯åœ¨ä»å¶å¾€æ ¹dfsä¸€éä¹‹åï¼ˆç›¸å½“äºé¢„å¤„ç†ï¼‰ï¼Œå†é‡æ–°å¾€ä¸‹è·å–æœ€åçš„ç­”æ¡ˆã€‚ ï¼‰
- 2.å¶->æ ¹ï¼ˆåœ¨å›æº¯çš„æ—¶å€™ä»å¶å­èŠ‚ç‚¹å¾€ä¸Šæ›´æ–°ä¿¡æ¯ï¼‰

### éš¾ç‚¹

- 1.åˆ©ç”¨é€’å½’+è®°å¿†åŒ–æœç´¢
- 2.ç»†èŠ‚å¤šï¼Œä»å­æ ‘ï¼Œä»çˆ¶äº²ï¼Œä»å…„å¼Ÿï¼Œ.......,æœ‰å°çš„è¦å¤„ç†çš„åœ°æ–¹ï¼Œè„‘å­ä¸æ¸…æ™°çš„æ—¶å€™åšèµ·æ¥é¢‡ä¸ºæ¶å¿ƒ
- çŠ¶æ€è¡¨ç¤ºå’Œè½¬ç§»æ–¹ç¨‹ï¼Œä¹Ÿæ˜¯çœŸæ­£éš¾çš„åœ°æ–¹ã€‚åšåˆ°åé¢ï¼Œæ ‘å½¢DPçš„è€å¥—è·¯éƒ½ä¹Ÿå°±é‚£ä¹ˆå¤šï¼Œéš¾çš„è¿˜æ˜¯æ€ä¹ˆèƒ½æƒ³å‡ºè½¬ç§»æ–¹ç¨‹ï¼Œå„ç§DPåšåˆ°æœ€åéƒ½æ˜¯è¿™æ ·ï¼

## çŠ¶å‹dp

çŠ¶å‹dpå°±æ˜¯å°†çŠ¶æ€å‹ç¼©æˆäºŒè¿›åˆ¶è¿›è¡Œä¿å­˜ï¼Œæ˜¯åˆ©ç”¨è®¡ç®—æœºäºŒè¿›åˆ¶çš„æ€§è´¨æ¥æè¿°çŠ¶æ€çš„ä¸€ç§dpæ–¹å¼ã€‚

æ³°éš¾

## æ•°ä½dp

æ•°ä½dpæœ‰ä¸ªé€šç”¨çš„å¥—è·¯ï¼Œå°±æ˜¯å…ˆé‡‡ç”¨**å‰ç¼€å’Œæ€æƒ³**ï¼Œå°†æ±‚è§£â€œ[ğ‘™,ğ‘Ÿ]è¿™ä¸ªåŒºé—´å†…çš„æ»¡è¶³çº¦æŸçš„æ•°çš„æ•°é‡â€ï¼Œè½¬åŒ–ä¸ºâ€œ[1,ğ‘Ÿ]æ»¡è¶³çº¦æŸçš„æ•°é‡ - åŒºé—´[1,ğ‘™âˆ’1]æ»¡è¶³çº¦æŸçš„æ•°é‡ã€‚

æ‰€ä»¥æˆ‘ä»¬æœ€ç»ˆè¦æ±‚è§£çš„é—®é¢˜é€šé€šè½¬åŒ–ä¸ºï¼š[1,ğ‘¥]ä¸­æ»¡è¶³çº¦æŸçš„æ•°é‡ï¼Œæˆ–è€…[0,ğ‘¥]ä¸­çš„æ»¡è¶³çº¦æŸçš„æ•°é‡ï¼ˆå·¦è¾¹ç•Œå–å†³äºé¢˜ç›®ï¼‰ï¼Œç„¶åå°†æ•°å­—ğ‘¥æ‹†åˆ†ä¸ºä¸€ä¸ªä¸ªæ•°ä½

$dp[i][j]çŠ¶æ€é€šå¸¸æ˜¯æ¥è¡¨ç¤ºåœ¨iä½æ•°ä¸­æ»¡è¶³å®šä¹‰çš„çŠ¶æ€jçš„æ•°çš„ä¸ªæ•°$

```cpp
LL solve(LL x)
{
    int len = 0;
    while(x > 0)
    {
        a[++ len] = x % 10;
        x /= 10;
    }
    return dfs(...); //è®°å¿†åŒ–æœç´¢
}
```

[ä¾‹é¢˜LuoguP4999](https://www.luogu.com.cn/problem/P4999)

æ±‚è§£åŒºé—´$[L,R]ä¸Šçš„æ‰€æœ‰æ•°çš„æ•°ä½å’Œä¹‹å’Œ$ï¼Œå¸¸å¸¸åˆ†è§£æˆ$[0,R] - [0,L - 1]$ä¹‹å’Œ

ç”¨dfså†™æ³•ï¼Œç”¨å½¢å‚posæ¥è¡¨ç¤ºå½“å‰æšä¸¾çš„ä½ç½®ï¼Œä¸€èˆ¬ä»é«˜åˆ°ä½ã€‚

ä¸¾ä¾‹ï¼šå‡è®¾xä¸º4132ï¼Œç”¨â€œï¼Ÿâ€æ¥è¡¨ç¤ºæš‚æœªå¡«å†™çš„æ•°ä½ï¼Œåˆ™ç°åœ¨å¡«æ•°çŠ¶æ€ä¸ºï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Œç¬¬ä¸€æ­¥æˆ‘ä»¬å¾—å…ˆå¡«å†™ç¬¬lenä½(æœ€é«˜ä½),æˆ‘ä»¬åªèƒ½å¡«å†™0~4<br>è‹¥å¡«å†™å¤§äº4çš„æ•°ç ,æ˜¾ç„¶ä¸åœ¨æˆ‘ä»¬çš„æšä¸¾èŒƒå›´é‡Œ<br>å¦‚æœå¡«å†™4çš„è¯ä¸‹é¢çš„æ•°å­—è¿˜æ˜¯ä¼šå—åˆ°é™åˆ¶ï¼Œä¸‹é¢çš„æ•°å­—å°±ä¸èƒ½å¡«è¶…è¿‡1çš„æ•°å­—<br>å¦‚æœå¡«å†™0~3çš„è¯ï¼Œå‰©ä¸‹çš„æ•°å­—å°±å¯ä»¥éšä¾¿å¡«å†™äº†,æ‰€ä»¥æˆ‘ä»¬éœ€è¦è®°å½•ä¸€ä¸ªå˜é‡$limit$ï¼Œè¡¨ç¤ºåœ¨å½“å‰æ•°ä½ä¸Šæ˜¯ä¸æ˜¯å¯ä»¥éšæ„å¡«å†™ã€‚

limit  : boolå€¼å˜é‡,è¡¨ç¤ºæšä¸¾çš„ç¬¬posä½æ˜¯å¦å—é™åˆ¶ã€‚è¯¥ä½ä¸ºtrueè¡¨ç¤ºå–å¾—æ•°ä¸èƒ½å¤§äº$a[pos]$,åªæœ‰å½“$[pos + 1,len]$çš„ä½ç½®å¡«å†™çš„æ•°éƒ½ç­‰äº$a[i]$æ—¶,è¯¥å€¼æ‰ä¸º$true$,å¦åˆ™è¡¨ç¤ºå½“å‰ä½æ²¡æœ‰é™åˆ¶,å¯ä»¥å–åˆ°[0,R - 1],R - 1è¡¨ç¤ºåœ¨Rè¿›åˆ¶ä¸‹æœ€å¤šèƒ½å–åˆ°çš„æ•°å­—ã€‚

å½“æˆ‘ä»¬æœç´¢åˆ°$pos = 0$çš„æ—¶å€™,è¡¨ç¤ºæ‰€æœ‰æ•°ä½éƒ½å·²ç»å¡«å†™å®Œæ¯•äº†,æ¯ä¸ªâ€œï¼Ÿâ€éƒ½è¢«æ›¿æ¢æˆäº†å…·ä½“çš„æ•°å­—ï¼Œè¿™å¯ä»¥ä½œä¸ºä¸€ä¸ªé€’å½’è¾¹ç•Œï¼Œæˆ‘ä»¬éœ€è¦è¿”å›æšä¸¾å¡«å†™çš„æ‰€æœ‰æ•°ä½å’Œsum,æ•…dfså‡½æ•°çš„å½¢å‚è¿˜å¾—æ·»åŠ ï¼š**sum**

sum: intå‹å˜é‡,è¡¨ç¤ºå½“å‰$(len \to pos + 1)$çš„æ•°ä½å’Œã€‚ä»¥ä¸Šæ˜¯æ™®é€šçš„dfsæœç´¢ï¼Œè€Œæ•°ä½dpå°±æ˜¯æŠŠç›¸åŒçš„éƒ¨åˆ†ç»™å»æ‰äº†

è®¾ç½®çŠ¶æ€$f[pos][sum]è¡¨ç¤ºä½ç½®[pos + 1,len]éƒ½å·²ç»å¡«å†™å®Œæ¯•ï¼Œä¸”è¿™äº›æ•°ä½ä¹‹å’Œä½sumçš„æƒ…å†µä¸‹ï¼Œæ•°ä½[1,pos]ä»»æ„å¡«å†™ã€‚$

$f[pos][sum]è¡¨ç¤ºæ»¡è¶³çº¦æŸçš„æ‰€æœ‰æ•°çš„æ•°ä½ä¹‹å’Œ$

```cpp
LL dfs(int pos, bool limit, int sum)
{
    if(!pos) //é€’å½’è¾¹ç•Œ
        return sum;
    if(!limit && ~f[pos][sum]) //æ²¡é™åˆ¶å¹¶ä¸”dpå€¼å·²æœç´¢è¿‡
        return f[pos][sum];
    int up = limit ? a[pos] : 9; //
    LL res = 0;
    for(int i = 0; i <= up; i ++)
        res = (res + dfs(pos - 1, limit && i == up, sum + i)) % md;
    if(!limit) //è®°æœï¼Œå¯å¤ç”¨
        f[pos][sum] = res;
    return res;
}
```

### è®°å¿†åŒ–dfså‡½æ•°å¸¸è§å½¢å‚

- $pos$ï¼šintå‹å˜é‡ï¼Œè¡¨ç¤ºå½“å‰æšä¸¾çš„ä½ç½®ï¼Œä¸€èˆ¬ä»é«˜åˆ°ä½

- ğ‘™ğ‘–ğ‘šğ‘–ğ‘¡ï¼šboolå‹å˜é‡ï¼Œè¡¨ç¤ºæšä¸¾çš„ç¬¬ğ‘ğ‘œğ‘ ä½æ˜¯å¦å—åˆ°**é™åˆ¶**ï¼Œ

- ä¸ºtrueè¡¨ç¤ºå–çš„æ•°ä¸èƒ½å¤§äºğ‘[ğ‘ğ‘œğ‘ ]ï¼Œè€Œåªæœ‰åœ¨[ğ‘ğ‘œğ‘ +1,ğ‘™ğ‘’ğ‘›]çš„ä½ç½®ä¸Šå¡«å†™çš„æ•°éƒ½ç­‰äºğ‘[ğ‘–]æ—¶è¯¥å€¼æ‰ä¸ºtrue

- å¦åˆ™è¡¨ç¤ºå½“å‰ä½æ²¡æœ‰é™åˆ¶ï¼Œå¯ä»¥å–åˆ°[0,ğ‘…âˆ’1]ï¼Œå› ä¸ºğ‘…è¿›åˆ¶çš„æ•°ä¸­æ•°ä½æœ€å¤šèƒ½å–åˆ°çš„å°±æ˜¯ğ‘…âˆ’1

- ğ‘™ğ‘ğ‘ ğ‘¡ï¼šintå‹å˜é‡ï¼Œè¡¨ç¤ºä¸Šä¸€ä½ï¼ˆç¬¬ğ‘ğ‘œğ‘ +1ä½ï¼‰å¡«å†™çš„å€¼,å¾€å¾€ç”¨äºçº¦æŸäº†ç›¸é‚»æ•°ä½ä¹‹é—´çš„å…³ç³»çš„é¢˜ç›®
- ğ‘™ğ‘’ğ‘ğ‘‘0ï¼šboolå‹å˜é‡ï¼Œè¡¨ç¤ºæ˜¯å¦æœ‰**å‰å¯¼é›¶**ï¼Œå³åœ¨ğ‘™ğ‘’ğ‘›â†’(ğ‘ğ‘œğ‘ +1)è¿™äº›ä½ç½®æ˜¯ä¸æ˜¯éƒ½æ˜¯**å‰å¯¼é›¶**
- - åŸºäºå¸¸è¯†ï¼Œæˆ‘ä»¬å¾€å¾€é»˜è®¤ä¸€ä¸ªæ•°æ²¡æœ‰å‰å¯¼é›¶ï¼Œä¹Ÿå°±æ˜¯æœ€é«˜ä½ä¸èƒ½ä¸º0ï¼Œå³ä¸ä¼šå†™ä¸º000123ï¼Œè€Œæ˜¯å†™ä¸º123

  - åªæœ‰æ²¡æœ‰å‰å¯¼é›¶çš„æ—¶å€™ï¼Œæ‰èƒ½è®¡ç®—0çš„è´¡çŒ®ã€‚

  - é‚£ä¹ˆå‰å¯¼é›¶ä½•æ—¶è·Ÿç­”æ¡ˆæœ‰å…³ï¼Ÿ

  - - ç»Ÿè®¡0çš„å‡ºç°æ¬¡æ•°
    - ç›¸é‚»æ•°å­—çš„å·®å€¼
    - ä»¥æœ€é«˜ä½ä¸ºèµ·ç‚¹ç¡®å®šçš„å¥‡å¶ä½
- ğ‘ ğ‘¢ğ‘šï¼šintå‹å˜é‡ï¼Œè¡¨ç¤ºå½“å‰ğ‘™ğ‘’ğ‘›â†’(ğ‘ğ‘œğ‘ +1)çš„æ•°ä½å’Œ
- ğ‘Ÿï¼šintå‹å˜é‡ï¼Œè¡¨ç¤ºæ•´ä¸ªæ•°å‰ç¼€å–æ¨¡æŸä¸ªæ•°ğ‘šçš„ä½™æ•°
- - è¯¥å‚æ•°ä¸€èˆ¬ä¼šç”¨åœ¨ï¼šçº¦æŸä¸­å‡ºç°äº†èƒ½è¢«ğ‘šæ•´é™¤
  - å½“ç„¶ä¹Ÿå¯ä»¥æ‹“å±•ä¸ºæ•°ä½å’Œå–æ¨¡çš„ç»“æœ
- ğ‘ ğ‘¡ï¼šintå‹å˜é‡ï¼Œç”¨äºçŠ¶æ€å‹ç¼©,å¯¹ä¸€ä¸ªé›†åˆçš„æ•°åœ¨æ•°ä½ä¸Šçš„å‡ºç°æ¬¡æ•°çš„å¥‡å¶æ€§æœ‰è¦æ±‚æ—¶ï¼Œå…¶äºŒè¿›åˆ¶å½¢å¼å°±å¯ä»¥è¡¨ç¤ºæ¯ä¸ªæ•°å‡ºç°çš„å¥‡å¶æ€§

# æ•°æ®ç»“æ„

## å¹¶æŸ¥é›†

### å¸¸è§„å¹¶æŸ¥é›†

```cpp
int f[N],d[N];
int find(int x){
    if(x == f[x]) return x;
    else return f[x] = find(f[x]);
}
int add(int x,int y){
    int fx = find(x),fy = find(y);
    if(fx != fy) f[fy] = fx;
}
```

### å¸¦æƒå¹¶æŸ¥é›†

å¸¦æƒå¹¶æŸ¥é›†å¯ä»¥å­˜å‚¨èŠ‚ç‚¹çš„æƒå€¼

```cpp
int FindSet(int x) {
    if (x == parent[x])
		return x;
    else {
		int t = parent[x]; //è®°å½•åŸçˆ¶èŠ‚ç‚¹ç¼–å·
		parent[x] = FindSet(parent[x]); //çˆ¶èŠ‚ç‚¹å˜ä¸ºæ ¹èŠ‚ç‚¹ï¼Œæ­¤æ—¶value[x]=çˆ¶èŠ‚ç‚¹åˆ°æ ¹èŠ‚ç‚¹çš„æƒå€¼
		value[x] += value[t]; //å½“å‰èŠ‚ç‚¹çš„æƒå€¼åŠ ä¸ŠåŸæœ¬çˆ¶èŠ‚ç‚¹çš„æƒå€¼
         return parent[x]
    }
}

```

å› ä¸ºåœ¨è·¯å¾„å‹ç¼©å**çˆ¶èŠ‚ç‚¹ç›´æ¥å˜ä¸ºæ ¹èŠ‚ç‚¹**ï¼Œæ­¤æ—¶çˆ¶èŠ‚ç‚¹çš„æƒå€¼å·²ç»æ˜¯çˆ¶èŠ‚ç‚¹åˆ°æ ¹èŠ‚ç‚¹çš„æƒå€¼äº†ï¼Œå°†å½“å‰èŠ‚ç‚¹çš„æƒå€¼åŠ ä¸ŠåŸæœ¬çˆ¶èŠ‚ç‚¹çš„æƒå€¼ï¼Œå°±å¾—åˆ°å½“å‰èŠ‚ç‚¹åˆ°æ ¹èŠ‚ç‚¹çš„æƒå€¼

```cpp
int merge(int x,int y,int s){
    int xRoot = findSet(x);
    int yRoot = findSet(y);
    if(xRoot != yRoot){
        parent[xRoot] = yRoot;
        value[xRoot] = -value[x] + value[y] + s;
    }
}
```





## stè¡¨

å½¢æˆ

```cpp
int f[MAXN][21]; // ç¬¬äºŒç»´çš„å¤§å°æ ¹æ®æ•°æ®èŒƒå›´å†³å®šï¼Œä¸å°äºlog(MAXN)
for (int i = 1; i <= n; ++i)
    f[i][0] = read(); // è¯»å…¥æ•°æ®
for (int i = 1; i <= 20; ++i)
    for (int j = 1; j + (1 << i) - 1 <= n; ++j)
        f[j][i] = max(f[j][i - 1], f[j + (1 << (i - 1))][i - 1]);
```

åŸç†å¦‚å›¾

![img](https://pic4.zhimg.com/v2-22d8a24faea894fb8ddceae627093bbf_b.jpg)

é€’æ¨log

```cpp
for (int i = 2; i <= n; ++i)
    Log2[i] = Log2[i / 2] + 1;
```

åœ¨çº¿æŸ¥è¯¢

```cpp
for (int i = 0; i < m; ++i)
{
    int l = read(), r = read();
    int s = Log2[r - l + 1];
    printf("%d\n", max(f[l][s], f[r - (1 << s) + 1][s]));
}
```

æ¨¡æ¿

```cpp
int A[N], f[__lg(N) + 1][N];
void init(int n) {
    for (int i = 1; i <= n; ++i)
        f[0][i] = A[i];
    for (int i = 1; i <= __lg(n); ++i)
        for (int j = 1; j + (1 << i) - 1 <= n; ++j)
            f[i][j] = max(f[i - 1][j], f[i - 1][j + (1 << (i - 1))]);
}
int query(int l, int r) {
    int s = __lg(r - l + 1);
    return max(f[s][l], f[s][r - (1 << s) + 1]);
}
```

## é“¾å¼å‰å‘æ˜Ÿ

```cpp
int head[N],cnt;
struct edge{
	int to,nxt,val;
}e[N];
int add(int u,int v){
	e[++cnt].to = v;
	e[cnt].nxt = head[u];
	head[u] = cnt;
}
```

### é“¾å¼å‰å‘æ˜Ÿçš„éå†

- *BFS*

  ```cpp
  void bfs(int u) ///é˜Ÿåˆ—å®ç°å¹¿åº¦ä¼˜å…ˆæœç´¢
  {
      queue<int>q;
      vis[u]=true;
      q.push(u);
      while(!q.empty()){
          int k=q.front();
          q.pop();
          printf("%d ",k);
          for(int i=head[k];~i;i=edge[i].next){
               int to=edge[i].to;
               if(!vis[to]){
                  q.push(to);
                  vis[to]=true; ///å› ä¸ºä¸æ˜¯é€’å½’å®ç°ï¼Œæ‰€ä»¥æ¯æ¬¡æ”¾å…¥é˜Ÿåˆ—åéƒ½éœ€è¦ç«‹å³æ ‡è®°ã€‚
               }
          }
      }
  }
  ```

- *DFS*

  ```cpp
  void dfs(int u) ///é€’å½’å®ç°æ·±åº¦ä¼˜å…ˆæœç´¢
  {
      printf("%d ",u);
      vis[u]=true;
      for(int i=head[u];i;i=edge[i].next){
          int to=edge[i].to;
          if(!vis[to]){
              dfs(to);
          }
      }
  }
  ```

## æ ‘çŠ¶æ•°ç»„

![img](https://img2018.cnblogs.com/blog/1448672/201810/1448672-20181003121604644-268531484.png)

é»‘è‰²æ•°ç»„ä»£è¡¨åŸæ¥çš„æ•°ç»„ï¼ˆä¸‹é¢ç”¨A[i]ä»£æ›¿ï¼‰ï¼Œçº¢è‰²ç»“æ„ä»£è¡¨æˆ‘ä»¬çš„æ ‘çŠ¶æ•°ç»„(ä¸‹é¢ç”¨C[i]ä»£æ›¿)ï¼Œæ¯ä¸ªä½ç½®åªæœ‰ä¸€ä¸ªæ–¹æ¡†ï¼Œä»¤æ¯ä¸ªä½ç½®å­˜çš„å°±æ˜¯å­èŠ‚ç‚¹çš„å€¼çš„å’Œï¼Œåˆ™æœ‰$C[1] = A[1], C[2] = A[1] + A[2], C[3] = A[3],  C[4] = A[1] + A[2] + A[3] + A[4],C[5] = A[5]$

$C[6] = A[5] + A[6],C[7] = A[7],C[8] = A[1] + A[2] + A[3] + A[4] + A[5] + A[6] + A[7] + A[8]$

$C[i] = A[i - 2^k + 1] + A[i - 2^k + 2] + ...... + A[i]$

æˆ‘ä»¬è¦æ‰¾å‰7é¡¹å’Œï¼Œé‚£ä¹ˆåº”è¯¥æ˜¯$SUM = C[7] + C[6] + C[4]$;

```cpp
int n;
int a[1005],c[1005];
int lowbit(int x){
    return x&(-x);
}
 
void updata(int i,int k){
     while(i <= n){
         c[i] += k;
         i += lowbit(i);
    }
 }
 int getsum(int i){     
     int res = 0;
     while(i > 0){
         res += c[i];
         i -= lowbit(i);
     }
     return res;
 }
```

### å•ç‚¹ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢

```cpp
void solve(){
    cin >> n >> m;
    for(int i = 1;i <= n;i++){
        int a;
        cin >> a;
        updata(i,a);
    }
    for(int i = 1;i <= m;i++){
        int op,x,y;
        cin >> op >> x >> y;
        if(op == 1) updata(x,y);
        if(op == 2) cout << getsum(y) - getsum(x -1) << '\n';
    }
}
signed main(){
    // std::ios::sync_with_stdio(false);
    // cin.tie(0);
    int T;
    T = 1;
    //cin >> T;
    while(T--){
        solve();
    }
}
```

### åŒºé—´ä¿®æ”¹ï¼Œå•ç‚¹æŸ¥è¯¢

åŒºé—´ä¿®æ”¹éœ€è¦ç”¨æ ‘çŠ¶æ•°ç»„æ¥å­˜å‚¨å·®åˆ†æ•°ç»„ï¼Œåœ¨æ ‘çŠ¶æ•°ç»„çš„ä¸¤ç«¯è¿›è¡Œå·®åˆ†æ•°ç»„çš„ä¿®æ”¹ï¼Œæ±‚å’Œæ—¶ç›´æ¥æ±‚å·®åˆ†æ•°ç»„çš„å‰ç¼€å’Œå°±å¯ä»¥å¾—åˆ°ä¿®æ”¹ä¹‹åçš„æ•°æ®ç‚¹ä¸Šçš„å€¼

```cpp
void solve(){
    cin >> n >> m;
    for(int i = 1;i <= n;i++){
        cin >> a[i];
        updata(i,a[i] - a[i - 1]);
    }
    for(int i = 1;i <= m;i++){
        int op;
        cin >> op;
        if(op == 1){
            int x,y,k;
            cin >> x >> y >> k; 
            updata(x,k);
            updata(y + 1,-k);
        }
        if(op == 2){
            int x;
            cin >> x;
            cout << getsum(x) << '\n';
        }
    }
}
```



## çº¿æ®µæ ‘

### çº¿æ®µæ ‘çš„åŸºæœ¬ç»“æ„å’Œå»ºæ ‘

çº¿æ®µæ ‘å°†æ¯ä¸ªé•¿åº¦ä¸ä¸º$1$çš„åŒºé—´åˆ’åˆ†æˆå·¦å³ä¸¤ä¸ªåŒºé—´é€’å½’æ±‚è§£ï¼ŒæŠŠæ•´ä¸ªçº¿æ®µåˆ’åˆ†ä¸ºä¸€ä¸ªæ ‘å½¢ç»“æ„ï¼Œé€šè¿‡åˆå¹¶å·¦å³ä¸¤åŒºé—´ä¿¡æ¯æ¥æ±‚å¾—è¯¥åŒºé—´çš„ä¿¡æ¯ã€‚è¿™ç§æ•°æ®ç»“æ„å¯ä»¥æ–¹ä¾¿çš„è¿›è¡Œå¤§éƒ¨åˆ†çš„åŒºé—´æ“ä½œ.

<img src="https://img2018.cnblogs.com/blog/1448672/201810/1448672-20181017013332469-105750075.png" alt="img" style="zoom: 50%;" />

å¯¹äºA[1:6] = {1,8,6,4,3,5}æ¥è¯´ï¼Œçº¿æ®µæ ‘å¦‚ä¸Šæ‰€ç¤ºï¼Œçº¢è‰²ä»£è¡¨æ¯ä¸ªç»“ç‚¹å­˜å‚¨çš„åŒºé—´ï¼Œè“è‰²ä»£è¡¨è¯¥åŒºé—´æœ€å€¼ï¼Œç»¿è‰²ä»£è¡¨åŒºé—´çš„ä¸‹æ ‡ã€‚

å¯ä»¥å‘ç°ï¼Œ**æ¯ä¸ªå¶å­ç»“ç‚¹çš„å€¼å°±æ˜¯æ•°ç»„çš„å€¼ï¼Œæ¯ä¸ªéå¶å­ç»“ç‚¹çš„åº¦éƒ½ä¸ºäºŒï¼Œä¸”å·¦å³ä¸¤ä¸ªå­©å­åˆ†åˆ«å­˜å‚¨çˆ¶äº²ä¸€åŠçš„åŒºé—´ã€‚æ¯ä¸ªçˆ¶äº²çš„å­˜å‚¨çš„å€¼ä¹Ÿå°±æ˜¯ä¸¤ä¸ªå­©å­å­˜å‚¨çš„å€¼çš„æœ€å¤§å€¼ã€‚**è®¾çˆ¶äº²èŠ‚ç‚¹çš„ä¸‹æ ‡ä¸º$fa$,å·¦å„¿å­çš„ä¸‹æ ‡ä¸º$l$,å³å„¿å­èŠ‚ç‚¹ä¸‹æ ‡ä¸º$r$,æ˜“å¾—$l = 2*fa,r = 2*fa + 1$,å› æ­¤çº¿æ®µæ ‘å»ºæ ‘éœ€è¦4*nçš„ç©ºé—´ã€‚

æˆ‘ä»¬é€šå¸¸é€šè¿‡$k<<1$æ¥å¯»æ‰¾å·¦å­©å­ï¼Œé€šè¿‡$k>>1$æ¥å¯»æ‰¾å³å­©å­

ä»¥ä¸‹æ¨¡æ¿æ±‚çš„æ˜¯åŒºé—´æœ€å¤§å€¼

#### åŒºé—´æœ€å¤§å€¼æ¨¡æ¿

```cpp
const int maxn = 	100005;
int a[maxn],t[maxn<<2];        //aä¸ºåŸæ¥åŒºé—´ï¼Œtä¸ºçº¿æ®µæ ‘

void Pushup(int k){        //æ›´æ–°å‡½æ•°ï¼Œè¿™é‡Œæ˜¯å®ç°æœ€å¤§å€¼ ï¼ŒåŒç†å¯ä»¥å˜æˆï¼Œæœ€å°å€¼ï¼ŒåŒºé—´å’Œç­‰
    t[k] = max(t[k<<1],t[k<<1|1]);
}
//é€’å½’æ–¹å¼å»ºæ ‘ build(1,1,n);
void build(int k,int l,int r){    //kä¸ºå½“å‰éœ€è¦å»ºç«‹çš„ç»“ç‚¹ï¼Œlä¸ºå½“å‰éœ€è¦å»ºç«‹åŒºé—´çš„å·¦ç«¯ç‚¹ï¼Œråˆ™ä¸ºå³ç«¯ç‚¹
    if(l == r)    //å·¦ç«¯ç‚¹ç­‰äºå³ç«¯ç‚¹ï¼Œå³ä¸ºå¶å­èŠ‚ç‚¹ï¼Œç›´æ¥èµ‹å€¼å³å¯
        t[k] = a[l];
    else{
        int m = l + ((r-l)>>1);    //måˆ™ä¸ºä¸­é—´ç‚¹ï¼Œå·¦å„¿å­çš„ç»“ç‚¹åŒºé—´ä¸º[l,m],å³å„¿å­çš„ç»“ç‚¹åŒºé—´ä¸º[m+1,r]
        build(k<<1,l,m);    //é€’å½’æ„é€ å·¦å„¿å­ç»“ç‚¹
        build(k<<1|1,m+1,r);    //é€’å½’æ„é€ å³å„¿å­ç»“ç‚¹
        Pushup(k);    //æ›´æ–°çˆ¶èŠ‚ç‚¹
    }
}
//é€’å½’æ–¹å¼æ›´æ–° updata(p,v,1,n,1);ã€ç‚¹æ›´æ–°ã€‘
void updata(int p,int v,int l,int r,int k){    //pä¸ºä¸‹æ ‡ï¼Œvä¸ºè¦åŠ ä¸Šçš„å€¼ï¼Œlï¼Œrä¸ºç»“ç‚¹åŒºé—´ï¼Œkä¸ºç»“ç‚¹ä¸‹æ ‡
    if(l == r)    //å·¦ç«¯ç‚¹ç­‰äºå³ç«¯ç‚¹ï¼Œå³ä¸ºå¶å­ç»“ç‚¹ï¼Œç›´æ¥åŠ ä¸Švå³å¯
        a[k] += v,t[k] += v;    //åŸæ•°ç»„å’Œçº¿æ®µæ ‘æ•°ç»„éƒ½å¾—åˆ°æ›´æ–°
    else{
        int m = l + ((r-l)>>1);    //måˆ™ä¸ºä¸­é—´ç‚¹ï¼Œå·¦å„¿å­çš„ç»“ç‚¹åŒºé—´ä¸º[l,m],å³å„¿å­çš„ç»“ç‚¹åŒºé—´ä¸º[m+1,r]
        if(p <= m)    //å¦‚æœéœ€è¦æ›´æ–°çš„ç»“ç‚¹åœ¨å·¦å­æ ‘åŒºé—´
            updata(p,v,l,m,k<<1);
        else    //å¦‚æœéœ€è¦æ›´æ–°çš„ç»“ç‚¹åœ¨å³å­æ ‘åŒºé—´
            updata(p,v,m+1,r,k<<1|1);
        Pushup(k);    //æ›´æ–°çˆ¶èŠ‚ç‚¹çš„å€¼
    }
}
//é€’å½’æ–¹å¼åŒºé—´æŸ¥è¯¢ query(L,R,1,n,1);
int query(int L,int R,int l,int r,int k){    //[L,R]å³ä¸ºè¦æŸ¥è¯¢çš„åŒºé—´ï¼Œlï¼Œrä¸ºç»“ç‚¹åŒºé—´ï¼Œkä¸ºç»“ç‚¹ä¸‹æ ‡
    if(L <= l && r <= R)    //å¦‚æœå½“å‰ç»“ç‚¹çš„åŒºé—´çœŸåŒ…å«äºè¦æŸ¥è¯¢çš„åŒºé—´å†…ï¼Œåˆ™è¿”å›ç»“ç‚¹ä¿¡æ¯ä¸”ä¸éœ€è¦å¾€ä¸‹é€’å½’
        return t[k];
    else{
        int res = -INF;    //è¿”å›å€¼å˜é‡ï¼Œæ ¹æ®å…·ä½“çº¿æ®µæ ‘æŸ¥è¯¢çš„ä»€ä¹ˆè€Œè‡ªå®šä¹‰
        int mid = l + ((r-l)>>1);    //måˆ™ä¸ºä¸­é—´ç‚¹ï¼Œå·¦å„¿å­çš„ç»“ç‚¹åŒºé—´ä¸º[l,m],å³å„¿å­çš„ç»“ç‚¹åŒºé—´ä¸º[m+1,r]
        if(L <= m)    //å¦‚æœå·¦å­æ ‘å’Œéœ€è¦æŸ¥è¯¢çš„åŒºé—´äº¤é›†éç©º
            res = max(res, query(L,R,l,m,k<<1));
        if(R > m)    //å¦‚æœå³å­æ ‘å’Œéœ€è¦æŸ¥è¯¢çš„åŒºé—´äº¤é›†éç©ºï¼Œæ³¨æ„è¿™é‡Œä¸æ˜¯else ifï¼Œå› ä¸ºæŸ¥è¯¢åŒºé—´å¯èƒ½åŒæ—¶å’Œå·¦å³åŒºé—´éƒ½æœ‰äº¤é›†
            res = max(res, query(L,R,m+1,r,k<<1|1));
        return res;    //è¿”å›å½“å‰ç»“ç‚¹å¾—åˆ°çš„ä¿¡æ¯
    }
}
void Pushdown(int k){    //æ›´æ–°å­æ ‘çš„lazyå€¼ï¼Œè¿™é‡Œæ˜¯RMQçš„å‡½æ•°ï¼Œè¦å®ç°åŒºé—´å’Œç­‰åˆ™éœ€è¦ä¿®æ”¹å‡½æ•°å†…å®¹
    if(lazy[k]){    //å¦‚æœæœ‰lazyæ ‡è®°
        lazy[k<<1] += lazy[k];    //æ›´æ–°å·¦å­æ ‘çš„lazyå€¼
        lazy[k<<1|1] += lazy[k];    //æ›´æ–°å³å­æ ‘çš„lazyå€¼
        t[k<<1] += lazy[k];        //å·¦å­æ ‘çš„æœ€å€¼åŠ ä¸Šlazyå€¼
        t[k<<1|1] += lazy[k];    //å³å­æ ‘çš„æœ€å€¼åŠ ä¸Šlazyå€¼
        lazy[k] = 0;    //lazyå€¼å½’0
    }
}

//é€’å½’æ›´æ–°åŒºé—´ updata(L,R,v,1,n,1);ã€åŒºé—´æ›´æ–°ã€‘
void updata(int L,int R,int v,int l,int r,int k){    //[L,R]å³ä¸ºè¦æ›´æ–°çš„åŒºé—´ï¼Œlï¼Œrä¸ºç»“ç‚¹åŒºé—´ï¼Œkä¸ºç»“ç‚¹ä¸‹æ ‡
    if(L <= l && r <= R){    //å¦‚æœå½“å‰ç»“ç‚¹çš„åŒºé—´çœŸåŒ…å«äºè¦æ›´æ–°çš„åŒºé—´å†…
        lazy[k] += v;    //æ‡’æƒ°æ ‡è®°
        t[k] += v;    //æœ€å¤§å€¼åŠ ä¸Švä¹‹åï¼Œæ­¤åŒºé—´çš„æœ€å¤§å€¼ä¹Ÿè‚¯å®šæ˜¯åŠ v
    }
    else{
        Pushdown(k);    //é‡éš¾ç‚¹ï¼ŒæŸ¥è¯¢lazyæ ‡è®°ï¼Œæ›´æ–°å­æ ‘
        int m = l + ((r-l)>>1);
        if(L <= m)    //å¦‚æœå·¦å­æ ‘å’Œéœ€è¦æ›´æ–°çš„åŒºé—´äº¤é›†éç©º
            update(L,R,v,l,m,k<<1);
        if(m < R)    //å¦‚æœå³å­æ ‘å’Œéœ€è¦æ›´æ–°çš„åŒºé—´äº¤é›†éç©º
            update(L,R,v,m+1,r,k<<1|1);
        Pushup(k);    //æ›´æ–°çˆ¶èŠ‚ç‚¹
    }
}
//é€’å½’æ–¹å¼åŒºé—´æŸ¥è¯¢ query(L,R,1,n,1);
int query(int L,int R,int l,int r,int k){    //[L,R]å³ä¸ºè¦æŸ¥è¯¢çš„åŒºé—´ï¼Œlï¼Œrä¸ºç»“ç‚¹åŒºé—´ï¼Œkä¸ºç»“ç‚¹ä¸‹æ ‡
    if(L <= l && r <= R)    //å¦‚æœå½“å‰ç»“ç‚¹çš„åŒºé—´çœŸåŒ…å«äºè¦æŸ¥è¯¢çš„åŒºé—´å†…ï¼Œåˆ™è¿”å›ç»“ç‚¹ä¿¡æ¯ä¸”ä¸éœ€è¦å¾€ä¸‹é€’å½’
        return t[k];
    else{
        Pushdown(k);    /**æ¯æ¬¡éƒ½éœ€è¦æ›´æ–°å­æ ‘çš„Lazyæ ‡è®°*/
        int res = -INF;    //è¿”å›å€¼å˜é‡ï¼Œæ ¹æ®å…·ä½“çº¿æ®µæ ‘æŸ¥è¯¢çš„ä»€ä¹ˆè€Œè‡ªå®šä¹‰
        int mid = l + ((r-l)>>1);    //måˆ™ä¸ºä¸­é—´ç‚¹ï¼Œå·¦å„¿å­çš„ç»“ç‚¹åŒºé—´ä¸º[l,m],å³å„¿å­çš„ç»“ç‚¹åŒºé—´ä¸º[m+1,r]
        if(L <= m)    //å¦‚æœå·¦å­æ ‘å’Œéœ€è¦æŸ¥è¯¢çš„åŒºé—´äº¤é›†éç©º
            res = max(res, query(L,R,l,m,k<<1));
        if(R > m)    //å¦‚æœå³å­æ ‘å’Œéœ€è¦æŸ¥è¯¢çš„åŒºé—´äº¤é›†éç©ºï¼Œæ³¨æ„è¿™é‡Œä¸æ˜¯else ifï¼Œå› ä¸ºæŸ¥è¯¢åŒºé—´å¯èƒ½åŒæ—¶å’Œå·¦å³åŒºé—´éƒ½æœ‰äº¤é›†
            res = max(res, query(L,R,m+1,r,k<<1|1));

        return res;    //è¿”å›å½“å‰ç»“ç‚¹å¾—åˆ°çš„ä¿¡æ¯
    }
}
```

#### åŒºé—´å’Œæ¨¡æ¿

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int MAXN = 1e5 + 5;
ll tree[MAXN << 2], mark[MAXN << 2], n, m, A[MAXN];
void push_down(int p, int len) //ä¸‹ä¼ æ ‡è®°
{
    if (len <= 1) return;
    tree[p << 1] += mark[p] * (len - len / 2);
    mark[p << 1] += mark[p];
    tree[p << 1 | 1] += mark[p] * (len / 2);
    mark[p << 1 | 1] += mark[p];
    mark[p] = 0;
}
void build(int p = 1, int cl = 1, int cr = n) //å»ºæ ‘
{
    if (cl == cr) return void(tree[p] = A[cl]);
    int mid = (cl + cr) >> 1;
    build(p << 1, cl, mid);
    build(p << 1 | 1, mid + 1, cr);
    tree[p] = tree[p << 1] + tree[p << 1 | 1];
}
ll query(int l, int r, int p = 1, int cl = 1, int cr = n) //æŸ¥è¯¢låˆ°rçš„åŒºé—´å’Œ
{
    if (cl >= l && cr <= r) return tree[p];
    push_down(p, cr - cl + 1);
    ll mid = (cl + cr) >> 1, ans = 0;
    if (mid >= l) ans += query(l, r, p << 1, cl, mid);
    if (mid < r) ans += query(l, r, p << 1 | 1, mid + 1, cr);
    return ans;
}
void update(ll l, ll r, ll d, ll p = 1, ll cl = 1, ll cr = n)
{
    if (cl > r || cr < l) return;
    else if (cl >= l && cr <= r){
        tree[p] += (cr - cl + 1) * d;
        if (cr > cl) mark[p] += d;
    }
    else{
        ll mid = (cl + cr) / 2;
        push_down(p, cr - cl + 1);
        update(l, r, d, p * 2, cl, mid);
        update(l, r, d, p * 2 + 1, mid + 1, cr);
        tree[p] = tree[p * 2] + tree[p * 2 + 1];
    }
}
int main()
{
    ios::sync_with_stdio(false);
    cin >> n >> m;
    for (int i = 1; i <= n; ++i)
        cin >> A[i];
    build();
    while (m--)
    {
        int o, l, r, d;
        cin >> o >> l >> r;
        if (o == 1)
            cin >> d, update(l, r, d);
        else
            cout << query(l, r) << '\n';
    }
    return 0;
}
```

####  åŒºé—´åŠ ï¼Œä¹˜

[LuoguP3373]("https://www.luogu.com.cn/problem/P3373")

```c++
#include <bits/stdc++.h>

#define MAXN 100010
#define ll long long

using namespace std;

int n, m, mod;
int a[MAXN];

struct Segment_Tree {
    ll sum, add, mul;
    int l, r;
}s[MAXN * 4];
void update(int pos) {
    s[pos].sum = (s[pos << 1].sum + s[pos << 1 | 1].sum) % mod;
    return;
}
void pushdown(int pos) { //pushdownçš„ç»´æŠ¤
    s[pos << 1].sum = (s[pos << 1].sum * s[pos].mul + s[pos].add * (s[pos << 1].r - s[pos << 1].l + 1)) % mod;
    s[pos << 1 | 1].sum = (s[pos << 1 | 1].sum * s[pos].mul + s[pos].add * (s[pos << 1 | 1].r - s[pos << 1 | 1].l + 1)) % mod;

    s[pos << 1].mul = (s[pos << 1].mul * s[pos].mul) % mod;
    s[pos << 1 | 1].mul = (s[pos << 1 | 1].mul * s[pos].mul) % mod;

    s[pos << 1].add = (s[pos << 1].add * s[pos].mul + s[pos].add) % mod;
    s[pos << 1 | 1].add = (s[pos << 1 | 1].add * s[pos].mul + s[pos].add) % mod;

    s[pos].add = 0;
    s[pos].mul = 1;
    return;
}

void build_tree(int pos, int l, int r) { //å»ºæ ‘
    s[pos].l = l;
    s[pos].r = r;
    s[pos].mul = 1;
    if (l == r) {
        s[pos].sum = a[l] % mod;
        return;
    }
    int mid = (l + r) >> 1;
    build_tree(pos << 1, l, mid);
    build_tree(pos << 1 | 1, mid + 1, r);
    update(pos);
    return;
}

void ChangeMul(int pos, int x, int y, int k) { //åŒºé—´ä¹˜æ³•
    if (x <= s[pos].l && s[pos].r <= y) {
        s[pos].add = (s[pos].add * k) % mod;
        s[pos].mul = (s[pos].mul * k) % mod;
        s[pos].sum = (s[pos].sum * k) % mod;
        return;
    }

    pushdown(pos);
    int mid = (s[pos].l + s[pos].r) >> 1;
    if (x <= mid) ChangeMul(pos << 1, x, y, k);
    if (y > mid) ChangeMul(pos << 1 | 1, x, y, k);
    update(pos);
    return;
}

void ChangeAdd(int pos, int x, int y, int k) { //åŒºé—´åŠ æ³•
    if (x <= s[pos].l && s[pos].r <= y) {
        s[pos].add = (s[pos].add + k) % mod;
        s[pos].sum = (s[pos].sum + k * (s[pos].r - s[pos].l + 1)) % mod;
        return;
    }

    pushdown(pos);
    int mid = (s[pos].l + s[pos].r) >> 1;
    if (x <= mid) ChangeAdd(pos << 1, x, y, k);
    if (y > mid) ChangeAdd(pos << 1 | 1, x, y, k);
    update(pos);
    return;
}

ll AskRange(int pos, int x, int y) { //åŒºé—´è¯¢é—®
    if (x <= s[pos].l && s[pos].r <= y) {
        return s[pos].sum;
    }

    pushdown(pos);
    ll val = 0;
    int mid = (s[pos].l + s[pos].r) >> 1;
    if (x <= mid) val = (val + AskRange(pos << 1, x, y)) % mod;
    if (y > mid) val = (val + AskRange(pos << 1 | 1, x, y)) % mod;
    return val;
}

int main() {
    cin >> n >> m >> mod;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    build_tree(1, 1, n);
    for (int i = 1; i <= m; i++) {
        int opt, x, y;
        cin >> opt >> x >> y;
        if (opt == 1) {
            int k;
            cin >> k;
            ChangeMul(1, x, y, k);
        }
        if (opt == 2) {
            int k;
            cin >> k;
            ChangeAdd(1, x, y, k);
        }
        if (opt == 3) {
            cout << AskRange(1,x,y);
        }
    }
    return 0;
}
```

## zkwçº¿æ®µæ ‘

ç†è®ºä¸Šèƒ½æ”¾$(0,2^n)$çš„æ•°ï¼Œåªèƒ½æŸ¥è¯¢$(1,2^n - 2)$çš„èŒƒå›´

éé€’å½’æ–¹å¼å»ºæ ‘ï¼Œå»ºçš„æ˜¯ä¸€ä¸ªæ»¡äºŒå‰æ ‘

```cpp
int N = 1 << __lg(n + 5) + 1;
vector<int> tree(N << 1);
for (int i = 1; i <= n; ++i)
    tree[i + N] = A[i];
for (int i = N; i; --i)
    tree[i] = tree[i << 1] + tree[i << 1 | 1];

```

### å•ç‚¹ä¿®æ”¹

```cpp
void update(int x, int d)
{
    for (int i = x + N; i; i >>= 1) 
        tree[i] += d;
}
```

### åŒºé—´æŸ¥è¯¢

```cpp
int query(int l, int r)
{
    int ans = 0;
    for (l += N - 1, r += N + 1; l ^ r ^ 1; l >>= 1, r >>= 1)
    {
        if (~l & 1) ans += tree[l ^ 1]; // å·¦ç«¯ç‚¹æ˜¯å·¦å„¿å­
        if (r & 1) ans += tree[r ^ 1]; // å³ç«¯ç‚¹æ˜¯å³å„¿å­
    }
    return ans;
}
```

### åŒºé—´ä¿®æ”¹

```cpp
void update(int l, int r, int d)
{
    int len = 1, cntl = 0, cntr = 0; // cntlã€cntræ˜¯å·¦ã€å³ä¸¤è¾¹åˆ†åˆ«å®é™…ä¿®æ”¹çš„åŒºé—´é•¿åº¦
    for (l += N - 1, r += N + 1; l ^ r ^ 1; l >>= 1, r >>= 1, len <<= 1)
    {
        tree[l] += cntl * d, tree[r] += cntr * d;
        if (~l & 1) tree[l ^ 1] += d * len, mark[l ^ 1] += d, cntl += len;
        if (r & 1) tree[r ^ 1] += d * len, mark[r ^ 1] += d, cntr += len;
    }
    for (; l; l >>= 1, r >>= 1)
        tree[l] += cntl * d, tree[r] += cntr * d;
}
```

### åŒºé—´ä¿®æ”¹çš„æŸ¥è¯¢

```cpp
int query(int l, int r)
{
    int ans = 0, len = 1, cntl = 0, cntr = 0;
    for (l += N - 1, r += N + 1; l ^ r ^ 1; l >>= 1, r >>= 1, len <<= 1)
    {
        ans += cntl * mark[l] + cntr * mark[r];
        if (~l & 1) ans += tree[l ^ 1], cntl += len;
        if (r & 1) ans += tree[r ^ 1], cntr += len;
    }
    for (; l; l >>= 1, r >>= 1)
        ans += cntl * mark[l] + cntr * mark[r];
    return ans;
}

```

### åŒºé—´åŠ ï¼ŒåŒºé—´æŸ¥è¯¢æœ€å¤§å€¼çš„æ¨¡æ¿

```cpp
void update(int l, int r, int d) {
    for (l += N - 1, r += N + 1; l ^ r ^ 1; l >>= 1, r >>= 1)
    {
        if (l < N) tree[l] = max(tree[l << 1], tree[l << 1 | 1]) + mark[l],
                    tree[r] = max(tree[r << 1], tree[r << 1 | 1]) + mark[r];
        if (~l & 1) tree[l ^ 1] += d, mark[l ^ 1] += d;
        if (r & 1) tree[r ^ 1] += d, mark[r ^ 1] += d;
    }
    for (; l; l >>= 1, r >>= 1)
        if (l < N) tree[l] = max(tree[l << 1], tree[l << 1 | 1]) + mark[l],
                    tree[r] = max(tree[r << 1], tree[r << 1 | 1]) + mark[r];
};
int query(int l, int r) {
    int maxl = -INF, maxr = -INF;
    for (l += N - 1, r += N + 1; l ^ r ^ 1; l >>= 1, r >>= 1)
    {
        maxl += mark[l], maxr += mark[r];
        if (~l & 1) cmax(maxl, tree[l ^ 1]);
        if (r & 1) cmax(maxr, tree[r ^ 1]);
    }
    for (; l; l >>= 1, r >>= 1)
        maxl += mark[l], maxr += mark[r];
    return max(maxl, maxr);
};
	
```

```cpp
struct seg{
    ll o[1 << 20];int L;
    void upt(int x){
        o[x] = o[x << 1] + o[x << 1|1];
    }
    void init(int n,int  *w){
        L = 2 << std::__lg(n + 1);
        for(int i = 1;i <= n;i++) o[L + i] = w[i];
        for(int i = L;i >= 1;--i) upt(i);
    }
    void upt(int p,int v){
        for(o[p += L] += v;p >>= 1;upt(p));
    }
    ll qry(int l,int r){
        l += L - 1,r += L + 1;
        ll ans = 0;
        for(;l^r^1;l >>=1,r>>=1){
            if((l&1) == 0) ans += o[l^1];
            if((r&1) == 0) ans += o[r^1];
        }
    }
    ll qry2(int l,int r){
        if(l == r) return o[l + L];
        ll le = o[l + L],ri = o[r + L]; 
        l += L,r += L;
        for(;l^r^1;l >>= 1,r >>= 1){
            if((l&1) == 0) le = le + o[l^1];
            if((r&1) == 1) ri = o[r^1] + ri;
        }
        return le + ri;
    }
}sgt; (ä¸å«åŒºé—´æŸ¥è¯¢)
```



## æ‰«æçº¿(ä¸å¤ªç†è§£modifyéƒ¨åˆ†ï¼‰

[LuoguP5490]("https://www.luogu.com.cn/problem/P5490")

```cpp
#include<bits/stdc++.h>
using std::cin,std::cout,std::deque,std::pair,std::queue,std::vector;
using LL = long long;
#define inf 0x3f3f3f3f
int qpow(int a, int n,int mod = 1e9 + 7){
    int ans = 1; while(n){if(n & 1){ans = a * ans%mod;}a = a * a%mod;n >>= 1;}return ans%mod;
}
// int head[N],cnt;
// struct edge{
// 	int to,nxt,val;
// }e[N];
// int add(int u,int v){
// 	e[++cnt].to = v;
// 	e[cnt].nxt = head[u];
// 	head[u] = cnt;
// }
const int N = 2e5 + 10;
int v[N];
struct l{
    int x,y1,y2,state;
    bool operator<(l a){
        return x < a.x;
    }
}line[N];
struct node{
    int l,r;
    long long len;
    int cover;
}sgt[N<<3];
inline int ls(int k){
    return k<<1;
}
inline int rs(int k){
    return k<<1|1;
}
inline void pushup(int k){
    if(sgt[k].cover) sgt[k].len = sgt[k].r - sgt[k].l;
    else sgt[k].len = sgt[ls(k)].len + sgt[rs(k)].len;
}
void built(int l,int r,int k = 1){
    sgt[k].l = v[l],sgt[k].r = v[r];
    if(r - l <= 1) return;
    int m = (l + r)>>1;
    built(l,m,ls(k));
    built(m,r,rs(k));
}
void modify(int x,int y,int z,int k = 1){
    int l = sgt[k].l,r = sgt[k].r;
    if(x <= l&&y >= r){
        sgt[k].cover+=z;
        pushup(k);
        return;
    }
    if(x < sgt[ls(k)].r) modify(x,y,z,ls(k));
    if(y > sgt[rs(k)].l) modify(x,y,z,rs(k));
    pushup(k);
}
void solve(){
    int n;
    cin >> n;
    int a,b,c,d;
    for(int i = 1;i <= n;i++){
        cin >> a >> b >> c >> d;
        v[i] = b,v[i + n] = d;
        line[i] = (l){a,b,d,1},line[i + n] = (l){c,b,d,-1};
    }
    std::sort(v + 1,v + 1 + (n << 1));
    std::sort(line + 1,line + 1 + (n << 1));
    built(1,n<<1);
    unsigned long long ans = 0;
    for(int i = 1;i <= (n << 1);i++){
        ans += sgt[1].len*(line[i].x - line[i - 1].x);
        modify(line[i].y1,line[i].y2,line[i].state);
    }
    cout << ans << '\n';
}
signed main(){
    std::ios::sync_with_stdio(false);
    cin.tie(0);
    int T = 1;
    // cin >> T;
    while(T--){
        solve();
    }
}
```

## åˆ†å—



# å›¾è®º

## åŸºç¡€æ¦‚å¿µ

åœ¨$G(V,E)ä¸­ï¼ŒVä½œä¸ºç‚¹é›†ï¼ŒEä½œä¸ºè¾¹é›†åˆ$

## ç®€å•å›¾

#### è‡ªç¯

$å¯¹Eçš„è¾¹e = (u,v),è‹¥u = v,åˆ™eè¢«æˆä¸ºä¸€ä¸ªè‡ªç¯$

#### é‡è¾¹

$è‹¥Eä¸­å­˜åœ¨ä¸¤ä¸ªå®Œå…¨ç›¸åŒçš„å…ƒç´ è¾¹(e_1,e_2),åˆ™ä»–ä»¬è¢«ç§°ä¸ºä¸€ç»„é‡è¾¹$

åœ¨æ— å‘å›¾ä¸­$(u,v)$å’Œ$(v,u)$ç®—ä¸€ç»„é‡è¾¹ï¼Œè€Œåœ¨æœ‰å‘å›¾ä¸­,$u\to v$å’Œ$v \to u$ä¸ä¸ºé‡è¾¹ã€‚

#### ç®€å•å›¾

**ç®€å•å›¾ (simple graph)**ï¼šè‹¥ä¸€ä¸ªå›¾ä¸­æ²¡æœ‰è‡ªç¯å’Œé‡è¾¹ï¼Œå®ƒè¢«ç§°ä¸ºç®€å•å›¾ã€‚å…·æœ‰è‡³å°‘ä¸¤ä¸ªé¡¶ç‚¹çš„ç®€å•æ— å‘å›¾ä¸­ä¸€å®šå­˜åœ¨åº¦ç›¸åŒçš„ç»“ç‚¹ã€‚



## æ‹“æ‰‘æ’åº

```cpp
int deg[MAXN], A[MAXN];
bool toposort(int n)
{
    int cnt = 0;
    queue<int> q;
    for (int i = 1; i <= n; ++i)
        if (deg[i] == 0)
            q.push(i);
    while (!q.empty())
    {
        int t = q.front();
        q.pop();
        A[cnt++] = t;
        for (auto to : edges[t])
        {
            deg[to]--;
            if (deg[to] == 0) // å‡ºç°äº†æ–°çš„å…¥åº¦ä¸º0çš„ç‚¹
                q.push(to);
        }
    }
    return cnt == n;
}
```



## å•å…ƒæœ€çŸ­è·¯å¾„é—®é¢˜ï¼ˆSSSPï¼‰

ï¼ˆx,y,zï¼‰æè¿°xå‡ºå‘åˆ°è¾¾yä¸”é•¿åº¦ä¸ºzçš„æœ‰å‘è¾¹ï¼Œdist[i]è¡¨ç¤ºä»èµ·ç‚¹1åˆ°èŠ‚ç‚¹içš„æœ€çŸ­è·¯å¾„çš„é•¿åº¦

### Dijkstraç®—æ³•

1.åˆå§‹åŒ–dist[1] = 0,å…¶ä½™èŠ‚ç‚¹çš„distä¸ºæ­£æ— ç©·å¤§

2.æ‰¾å‡ºä¸€ä¸ªæœªè¢«æ ‡è®°çš„,dist[x]æœ€å°çš„èŠ‚ç‚¹xï¼Œç„¶åæ ‡è®°èŠ‚ç‚¹x

3.æ‰«æèŠ‚ç‚¹æ‰€æœ‰çš„å‡ºè¾¹ï¼ˆx,y,zï¼‰ï¼Œè‹¥dist[y] > dist[x] + z,åˆ™ç”¨åè€…æ›´æ–°dist[y]

#### O^2åšæ³•

```cpp
int a[3010][3010],d[3010],n,m;
bool v[3010];
void dijkstra(){
    memset(d,0x3f,sizeof(d));
    memset(v,0,sizeof(v));
    d[1] = 0;
    for(int i = 1;i < n;i++){
        int x = 0;
        for(int j = 1;j <= n;j++){

            if(!v[j] && (x == 0 || d[j] < d[x])) x = j;
            v[x] = 1;//å·²ç»èµ°è¿‡äº†
            for(int y = 1;y <= n;y++){
                d[y] = min(d[y],d[x] + a[x][y]);
            } 
        }
    }
}
int main(){
    cin >> n >> m;
    memset(a,0x3f,sizeof(a));
    for(int i = 1;i <= n;i++) a[i][i] = 0;
    for(int i = 1;i <= m;i++){
        int x,y,z;
        cin >> x >> y >> z;
        a[x][y] = min(a[x][y],z);
    }
    dijkstra();
    for(int i = 1;i <= n;i++){
        cout << d[i];
    }
}
```

#### äºŒå‰å †ä¼˜åŒ–ï¼ˆmlognï¼‰

```cpp
bool v[N];
int d[N];
int n,m,tot,s;
struct S{
    int to,nxt,val;
}e[N];
void add1(int u,int v,int z){
    e[++cnt].to = v;
    e[cnt].nxt = head[u];
    e[cnt].val = z;
    head[u] = cnt;
}
std::priority_queue<std::pair<int,int>>q;
void dijkstra(){
    memset(d,0x3f,sizeof(d));
    memset(v,0,sizeof(v));
    d[s] = 0;   //sä¸ºåŸç‚¹
    q.push(std::make_pair(0,s));
    while(q.size()){
        int x = q.top().second;q.pop();
        if(v[x]) continue;
        v[x] = 1;
        for(int i = head[x];i;i = e[i].nxt){
            int y = e[i].to,z = e[i].val;
            if(d[y] > d[x] + z){
                d[y] = d[x] + z;
                q.push(std::make_pair(-d[y], y));
            }
        }
    }
}
int main(){
    cin >> n >> m;
    for(int i = 1;i <= m;i++){
        int x,y,z;
        cin >> x >> y >> z;
        add(x,y,z);
    }
    dijkstra();
    for(int i = 1;i <= n;i++){
        cout << d[i] << '\n';
    }
}
```

- ç»™å®šä¸€å¼ å›¾ï¼Œå¯¹äºå›¾ä¸­çš„æŸä¸€æ¡è¾¹ï¼ˆx,y,zï¼‰,æœ‰dist[y] <= dist[x] + zæˆç«‹ï¼Œç§°è¯¥è¾¹æ»¡è¶³ä¸‰è§’å½¢ä¸ç­‰å¼ã€‚è‹¥æ‰€æœ‰è¾¹éƒ½æ»¡è¶³ä¸‰è§’å½¢ä¸ç­‰å¼ï¼Œåˆ™distæ•°ç»„å°±æ˜¯æ‰€æ±‚æœ€çŸ­è·¯ã€‚
- åŸºäºè¿­ä»£æ–¹æ³•çš„Bellman-Fordç®—æ³•ï¼š

1.å»ºç«‹ä¸€ä¸ªé˜Ÿåˆ—ä¸€å¼€å§‹åªæœ‰èµ·ç‚¹1

2.å–å‡ºé˜Ÿå¤´èŠ‚ç‚¹xï¼Œæ‰«æä»–çš„æ‰€æœ‰å‡ºè¾¹ï¼ˆx,y,zï¼‰ï¼Œè‹¥dist[y]>dist[x] + zåˆ™ç”¨dist[x] + z æ¥æ›´æ–°dist[y]

### SPFA(Bellman-Fordç®—æ³•ä¼˜åŒ–)

```cpp
const int N = 10010,M = 10010;
int head[N],ver[M],edge[M],next[M],d[N];
int n,m,tot;
queue<int>q;
bool v[N];
void add1(int u,int v,int z){
    e[++cnt].to = v;
    e[cnt].nxt = head[u];
    e[cnt].val = z;
    head[u] = cnt;
}
void spfa(){
    memset(d,0x3f,sizeof(d));
    memset(v,0,sizeof(v));
    d[1] = 0;v[1] = 1;
    q.push(1);
    while(q.size()){
        int x = q.front();
        q.pop();
        v[x] = 0;
        for(int i = head[x];i;i = e[i].nxt){
            int y = e[i].to,z = e[i].val;
            if(d[y] > d[x] + z){
                d[y] = d[x] + z;
                if(!v[y]) q.push(y),v[y] = 1;
            }
        }
    }
}
int main(){
    cin >> n >> m;
    for(int i = 1;i <= m;i++){
        int x,y,z;
        cin >> x >> y >> z;
        add(x,y,z);
    }
    spfa();
    for(int i = 1;i <= n;i++){
        cout << d[i];
    }
}
```

## ï¼ˆæœ€è¿‘å…¬å…±ç¥–å…ˆï¼‰LCA

æ±‚ä¸¤ä¸ªç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ

```cpp
#include <bits/stdc++.h>
using namespace std;
struct edge {
    int to, nxt, val;
} e[100000001];
int head[100001], cnt;
void add(int from, int to) {
    e[++cnt].to = to;
    e[cnt].nxt  = head[from];
    head[from]  = cnt;
}
int depth[500001], fa[500001][22], lg[500001];
void dfs(int now, int fath) {
    fa[now][0] = fath;
    depth[now] = depth[fath] + 1;
    for (int i = 1; i <= lg[depth[now]]; i++) {
        fa[now][i] = fa[fa[now][i - 1]][i - 1];
    }
    for (int i = head[now]; i; i = e[i].nxt) {
        if (e[i].to != fath) dfs(e[i].to, now);
    }
}
int LCA(int x, int y) {
    if (depth[x] < depth[y]) swap(x, y);
    while (depth[x] > depth[y]) {
        x = fa[x][lg[depth[x] - depth[y]] - 1];
    }
    if (x == y) return x;
    for (int k = lg[depth[x]] - 1; k >= 0; k--)
        if (fa[x][k] != fa[y][k]) x = fa[x][k], y = fa[y][k];
    return fa[x][0];
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, m, s;
    cin >> n >> m >> s; //sæŒ‡çš„æ˜¯
    for (int i = 1; i <= n - 1; i++) {
        int x, y;
        cin >> x >> y;
        add(x, y);
        add(y, x);
    }
    for (int i = 1; i <= n; ++i)
        lg[i] = lg[i - 1] + (1 << lg[i - 1] == i);
    dfs(s, 0);
    for (int i = 1; i <= m; i++) {
        int x, y;
        cin >> x >> y;
        cout << LCA(x, y) << '\n' << flush;
    }
    system("pause");
    return 0;
}
```



## æœ€å°ç”Ÿæˆæ ‘

### Primç®—æ³•

```cpp
int head[maxn],dis[maxn],cnt,n,m,tot,now=1,ans;
int prim(){
    //å…ˆæŠŠdisæ•°ç»„é™„ä¸ºæå¤§å€¼
	for(int i=2;i<=n;++i){
		dis[i]=inf;
	}
    //è¿™é‡Œè¦æ³¨æ„é‡è¾¹ï¼Œæ‰€ä»¥è¦ç”¨åˆ°min
	for(int i=head[1];i;i=e[i].next){
		dis[e[i].to]=std::min(dis[e[i].to],e[i].val);
	}
    while(++tot<n){
        int minn=inf;
        vis[now]=1;
        for(int i=1;i<=n;++i){
            if(!vis[i]&&minn>dis[i]){
                minn=dis[i];
				now=i;
            }
        }
        ans+=minn;
        //æšä¸¾nowçš„æ‰€æœ‰è¿è¾¹ï¼Œæ›´æ–°disæ•°ç»„
        for(int i=head[now];i;i=e[i].next){
        	int v=e[i].to;
        	if(dis[v]>e[i].val&&!vis[v]){
        		dis[v]=e[i].val;
        	}
		}
    }
    return ans;
}
```



### Kruscalç®—æ³•

```cpp
#include<bits/stdc++.h>
using namespace std;
int read()
{
    re int x=0,f=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
    while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return x*f;
}
struct Edge{
	int u,v,w;
}edge[200005];
int fa[5005],n,m,ans,eu,ev,cnt;
bool cmp(Edge a,Edge b)
{
    return a.w<b.w;
}
//å¿«æ’çš„ä¾æ®ï¼ˆæŒ‰è¾¹æƒæ’åºï¼‰
int find(int x)
{
    while(x!=fa[x]) x=fa[x]=fa[fa[x]];
    return x;
}
//å¹¶æŸ¥é›†å¾ªç¯å®ç°æ¨¡æ¿ï¼ŒåŠè·¯å¾„å‹ç¼©ï¼Œä¸æ‡‚å¹¶æŸ¥é›†çš„åŒå­¦å¯ä»¥æˆ³ä¸€æˆ³ä»£ç ä¸Šæ–¹çš„â€œå¹¶æŸ¥é›†è¯¦è§£â€
void kruskal(){
    sort(edge,edge+m,cmp);
    //å°†è¾¹çš„æƒå€¼æ’åº
    for(re int i=0;i<m;i++){
        eu=find(edge[i].u), ev=find(edge[i].v);
        if(eu==ev) continue;
        //è‹¥å‡ºç°ä¸¤ä¸ªç‚¹å·²ç»è”é€šäº†ï¼Œåˆ™è¯´æ˜è¿™ä¸€æ¡è¾¹ä¸éœ€è¦äº†
        ans+=edge[i].w;
        //å°†æ­¤è¾¹æƒè®¡å…¥ç­”æ¡ˆ
        fa[ev]=eu;
        //å°†euã€evåˆå¹¶
        if(++cnt==n-1) break;
        //å¾ªç¯ç»“æŸæ¡ä»¶ï¼ŒåŠè¾¹æ•°ä¸ºç‚¹æ•°å‡ä¸€æ—¶
    }
}
int main()
{
    n=read(),m=read();
    for(int i=1;i<=n;i++){
        fa[i]=i;
    }
    //åˆå§‹åŒ–å¹¶æŸ¥é›†
    for(int i=0;i<m;i++)
    {
        edge[i].u=read(),edge[i].v=read(),edge[i].w=read();
    }
    kruskal();
    cout <
    return 0;
}
```

## åŒˆç‰™åˆ©ç®—æ³•

ï¼ˆç›®çš„æ˜¯å°½å¯èƒ½æ›´å¤šçš„åŒ¹é…ï¼‰

æŠŠäºŒåˆ†å›¾åˆ†ä¸ºA,Bä¸¤ä¸ªé›†åˆï¼Œä¾æ¬¡æšä¸¾Aä¸­çš„æ¯ä¸ªç‚¹ï¼Œè¯•å›¾åœ¨Bé›†åˆä¸­æ‰¾åˆ°ä¸€ä¸ªåŒ¹é…ã€‚å¯¹äºAé›†åˆä¸­ä¸€ä¸ªç‚¹xï¼Œå‡è®¾Bé›†åˆä¸­æœ‰ä¸€ä¸ªä¸å…¶ç›¸è¿çš„ç‚¹y,è‹¥yæš‚æ—¶è¿˜æ²¡æœ‰åŒ¹é…ç‚¹ï¼Œé‚£ä¹ˆxå¯ä»¥ä¸yåŒ¹é…ï¼šæ‰¾åˆ°ï¼›

å¦‚æœyå·²ç»æœ‰åŒ¹é…ç‚¹äº†ï¼Œåˆ™å›æº¯yåŒ¹é…çš„ç‚¹zï¼Œå°è¯•ç€ä¸ºzæ‰¾ä¸€ä¸ªé™¤äº†yä¹‹å¤–çš„åŒ¹é…ç‚¹ï¼Œå¦‚æœæ‰¾åˆ°äº†ï¼Œxå’Œyå¯ä»¥åŒ¹é…ï¼Œå¦åˆ™ä¸¤è€…æ— æ³•åŒ¹é…ã€‚

```cpp
int M, N;            //M, Nåˆ†åˆ«è¡¨ç¤ºå·¦ã€å³ä¾§é›†åˆçš„å…ƒç´ æ•°é‡
int Map[MAXM][MAXN]; //é‚»æ¥çŸ©é˜µå­˜å›¾
int p[MAXN];         //è®°å½•å½“å‰å³ä¾§å…ƒç´ æ‰€å¯¹åº”çš„å·¦ä¾§å…ƒç´ 
bool vis[MAXN];      //è®°å½•å³ä¾§å…ƒç´ æ˜¯å¦å·²è¢«è®¿é—®è¿‡
bool match(int i)
{
    for (int j = 1; j <= N; ++j)
        if (Map[i][j] && !vis[j]) //æœ‰è¾¹ä¸”æœªè®¿é—®
        {
            vis[j] = true;                 //è®°å½•çŠ¶æ€ä¸ºè®¿é—®è¿‡
            if (p[j] == 0 || match(p[j])) //å¦‚æœæš‚æ— åŒ¹é…ï¼Œæˆ–è€…åŸæ¥åŒ¹é…çš„å·¦ä¾§å…ƒç´ å¯ä»¥æ‰¾åˆ°æ–°çš„åŒ¹é…
            {
                p[j] = i;    //å½“å‰å·¦ä¾§å…ƒç´ æˆä¸ºå½“å‰å³ä¾§å…ƒç´ çš„æ–°åŒ¹é…
                return true; //è¿”å›åŒ¹é…æˆåŠŸ
            }
        }
    return false; //å¾ªç¯ç»“æŸï¼Œä»æœªæ‰¾åˆ°åŒ¹é…ï¼Œè¿”å›åŒ¹é…å¤±è´¥
}
int Hungarian()
{
    int cnt = 0;
    for (int i = 1; i <= M; ++i)
    {
        memset(vis, 0, sizeof(vis)); //é‡ç½®visæ•°ç»„
        if (match(i))
            cnt++;
    }
    return cnt;
}
```

### æœ€å°ç‚¹è¦†ç›–

æƒ³æ‰¾åˆ°æœ€å°‘çš„ç‚¹çš„æ•°é‡ï¼Œä½¿å¾—äºŒåˆ†å›¾çš„æ‰€æœ‰è¾¹éƒ½æœ‰ä¸€ä¸ªç«¯ç‚¹åœ¨è¿™äº›ç‚¹ä¸­ï¼ˆå°±æ˜¯åˆ é™¤æ‰è¿™ä¹ˆå¤šæ•°é‡çš„ç‚¹èƒ½å¤Ÿè®©æ‰€æœ‰çš„è¾¹èƒ½æ¶ˆå¤±ï¼‰

æ ¹æ®**KÃ¶nigå®šç†**å¯ä»¥å¾—çŸ¥ï¼Œä¸€ä¸ªäºŒåˆ†å›¾ä¸­çš„æœ€å¤§åŒ¹é…æ•°**ç­‰äº**è¿™ä¸ªå›¾ä¸­çš„æœ€å°ç‚¹è¦†ç›–æ•°ã€‚äºæ˜¯å¾—è§£ã€‚

## Tarjanç®—æ³•

### æ±‚å‰²ç‚¹

å‰²ç‚¹çš„æ€§è´¨:

1.å¦‚æœTçš„æ ¹èŠ‚ç‚¹æ˜¯ä¸€ä¸ªå‰²ç‚¹ï¼Œå½“ä¸”ä»…å½“æ ¹èŠ‚ç‚¹æœ‰ä¸¤ä¸ªæˆ–è€…æ›´å¤šçš„å­èŠ‚ç‚¹

2.Tçš„éæ ¹èŠ‚ç‚¹curæ˜¯å‰²ç‚¹ï¼Œå½“ä¸”ä»…å½“curå­˜åœ¨ä¸€ä¸ªå­èŠ‚ç‚¹nxt,nxtå’Œä»–çš„åä»£éƒ½æ²¡æœ‰å›é€€è¾¹è¿å‘curçš„ç¥–å…ˆ

[æ±‚å‰²ç‚¹](https://www.luogu.com.cn/problem/P3388)

```cpp
#include<bits/stdc++.h>
using std::cin,std::cout,std::deque,std::pair,std::queue,std::vector;
using LL = long long;
#define inf 0x3f3f3f3f
int qpow(int a, int n,int mod = 1e9 + 7){
    int ans = 1; while(n){if(n & 1){ans = a * ans%mod;}a = a * a%mod;n >>= 1;}return ans%mod;
}
const int N = 2e5 + 10;
int head[N << 1],cnt;
struct edge{
	int to,nxt,val;
}e[N<<1];
bool isCut[N];
void add(int u,int v){
	e[++cnt].to = v;
	e[cnt].nxt = head[u];
	head[u] = cnt;
}
int low[N],dfn[N];
int tot = 0;
void tarjan(int now,int root){
    low[now] = dfn[now] = ++tot;
    int child = 0;
    for(int i = head[now];i;i = e[i].nxt){
        int to = e[i].to;
        if(!dfn[to]){
            child++;
            tarjan(to,root);
            low[now] = std::min(low[now],low[to]);
            if(low[to] >= dfn[now] and now != root){
                isCut[now] = true;
            }
        }
        low[now] = std::min(low[now],dfn[to]);
    }
    if(child >= 2 && now == root){
        isCut[root] = true;
    }
}
void solve(){
    int n,m;
    cin >> n >> m;
    for(int i = 1;i <= m;i++){
        int u,v;
        cin >> u >> v;
        add(u,v);
        add(v,u);
    }
    for(int root = 1;root <= n;root++){
        if(!dfn[root]) tarjan(root,root);
    }
    vector<int> ans;
    for(int i = 1;i <= n;i++){
        if(isCut[i]) ans.push_back(i);
    }
    cout << ans.size() << '\n';
    for(int i:ans){
        cout << i << ' ';
    }
    cout << '\n';
}
signed main(){
    std::ios::sync_with_stdio(false);
    cin.tie(0);
    int T;
    T = 1;
    // cin >> T;
    while(T--){
        solve();
    }
}
```

### ç‚¹åŒè¿é€šåˆ†é‡ï¼ˆvDccï¼‰

ç‚¹åŒè¿é€šåˆ†é‡:ä¸€ä¸ªå›¾ä¸­,ç‚¹åŒè¿é€šçš„æå¤§å­å›¾ä¸ºä¸€ä¸ªç‚¹åŒè¿é€šåˆ†é‡ã€‚

æ€§è´¨ï¼šæˆ‘ä»¬ä½¿ç”¨dfsæ‰¾åˆ°ä¸€ä¸ªå‰²ç‚¹ä¹‹åï¼Œå®é™…ä¸Šå·²ç»å®Œæˆäº†ä¸€ä¸ªå¯¹äºä¸€ä¸ªç‚¹åŒè¿é€šåˆ†é‡çš„è®¿é—®ã€‚

ä½¿ç”¨ä¸€ä¸ªæ ˆæ¥ä¿å­˜dfsçš„é¡ºåºã€‚

å’Œå‰²ç‚¹æœ‰å…³ç³»

### è¾¹åŒè¿é€šåˆ†é‡(eDCC)

æ€§è´¨:lowå€¼ç›¸åŒçš„ç‚¹ï¼Œå¿…å®šåœ¨ä¸€ä¸ªè¾¹åŒé‡Œã€‚

### å¼ºè¿é€šå›¾ç¼©ç‚¹

å¼ºè¿é€šå›¾æŒ‡çš„æ˜¯ä¸€å¼ æœ‰å‘å›¾å†…æ¯ä¸ªç‚¹ä¸€ç‚¹éƒ½èƒ½åˆ°è¾¾ä»»æ„çš„ä¸€ä¸ªç‚¹

**å¦‚æœä»»æ„ä¸¤ç‚¹é—´å­˜åœ¨è·¯å¾„ï¼Œæ­¤ç§°æ­¤å›¾å…·æœ‰è¿é€šæ€§**ï¼Œå¦‚ä¸‹çš„å›¾ç»“æ„å…·æœ‰è¿é€šæ€§ã€‚æåŠè¿é€šæ€§ï¼Œå°±ä¸å¾—ä¸è¯´è¿é€šåˆ†é‡ï¼Œé€šä¿—è€Œè¨€ï¼ŒæŒ‡ç»“æ„ä¸­æœ‰å¤šå°‘ä¸ªè¿é€šé€šé“ï¼Œå¦‚ä¸‹çš„å›¾ç»“æ„åªæœ‰ä¸€ä¸ªè¿é€šé€šé“ï¼Œä¹Ÿå°±æ˜¯ä¸€ä¸ªè¿é€šåˆ†é‡ï¼Œæ‰€æœ‰èŠ‚ç‚¹åœ¨è¿™ä¸ªè¿é€šé€šé“ä¸Šéƒ½èƒ½äº’é€šã€‚

å¼ºè¿é€šæ˜¯æœ‰å‘å›¾çš„ç‰¹å®šæ¦‚å¿µã€‚**æœ‰å‘å›¾ä¸­ï¼Œä»»æ„ä¸¤ç‚¹ä¹‹é—´éƒ½å¯ä»¥è¿é€šï¼Œåˆ™è®¤å®šæ­¤æœ‰å‘å›¾ä¸ºå¼ºè¿é€šå›¾**

è‹¥dfn[u] == low[u]è¿™è¯´æ˜äº†ğ‘¢ç‚¹åŠğ‘¢ç‚¹ä¹‹ä¸‹çš„æ‰€æœ‰å­èŠ‚ç‚¹æ²¡æœ‰è¾¹æ˜¯æŒ‡å‘uçš„ç¥–å…ˆçš„äº†ï¼Œå³æˆ‘ä»¬ä¹‹å‰è¯´çš„ğ‘¢ç‚¹ä¸å®ƒçš„å­å­™èŠ‚ç‚¹æ„æˆäº†ä¸€ä¸ªæœ€å¤§çš„å¼ºè¿é€šå›¾å³å¼ºè¿é€šåˆ†é‡.

ä¾‹é¢˜ï¼š[LuoguP3387(æ¨¡æ¿ã€ç¼©ç‚¹ã€‘)](https://www.luogu.com.cn/problem/P3387).

```cpp
//tarjan
struct edge
{
	int to,nxt,from,val;
}e[maxn*10],ed[maxn*10];
void add(int x,int y)
{
	e[++cnt].from = x;
    e[cnt].to = y;
   	head[x] = cnt;
}
int dfn[N], low[N], dfncnt, s[N], in_stack[N], tp;
int scc[N], sc;  // ç»“ç‚¹ i æ‰€åœ¨ SCC çš„ç¼–å·
int sz[N];       // å¼ºè¿é€š i çš„å¤§å°

void tarjan(int u) {
    low[u] = dfn[u] = ++dfncnt, s[++tp] = u, in_stack[u] = 1;
    for (int i = head[u]; i; i = e[i].nxt) {
        const int &v = e[i].to;
        if (!dfn[v]) {
            tarjan(v);
            low[u] = std::min(low[u], low[v]);
        } else if (in_stack[v]) {
          low[u] = std::min(low[u], dfn[v]);
        }
    }
    if (dfn[u] == low[u]) {
        ++sc;
        while (s[tp] != u) {
            scc[s[tp]] = sc;
            sz[sc]++;
            in_stack[s[tp]] = 0;
            --tp;
        }
        scc[s[tp]] = sc;
        sz[sc]++;
        in_stack[s[tp]] = 0;
        --tp;
    }
}
int main(){
    int n;
    cin >> n;
    for(int i=1;i<=n;i++)
        if(!dfn[i])tarjan(i);
    for(int i=1;i<=n;i++)
	{
		for(int j=head[i];j;j=e[j].nxt)
		{
			int xx=e[j].to;// åŸè¾¹ï¼Œè‹¥ä¸æ˜¯ä¸€ä¸ªå¼ºè”é€šåˆ†é‡çš„ï¼Œå†åœ¨ç°å›¾ä¸ŠåŠ è¾¹ 
			if(color[i]!=color[xx])
			add_edge(color[i],color[xx]);// åŠ è¾¹ 
		}
	}
    return 0;
}

```



## ç½‘ç»œæœ€å¤§æµ

æ‹¥æœ‰æºç‚¹è¿˜æœ‰ä¸€ä¸ªæ±‡ç‚¹ï¼Œå…¶ä¸Šçš„è¾¹æƒç§°ä¸ºå®¹é‡ï¼Œç½‘ç»œæµä¸­å¸¸è§çš„é—®é¢˜å°±æ˜¯ç½‘ç»œæœ€å¤§æµï¼Œå‡å®šä»æºç‚¹æµå‡ºçš„æµé‡è¶³å¤Ÿå¤šï¼Œæ±‚èƒ½å¤Ÿæµå…¥æ±‡ç‚¹çš„æœ€å¤§æµé‡

è§£å†³è¿™ä¸ªé—®é¢˜æœ€å¸¸ç”¨çš„æ˜¯Ford-Fulkersonç®—æ³•åŠå…¶ä¼˜åŒ–ã€‚

![img](https://pic3.zhimg.com/80/v2-1c4016f73a2e94109fbb8769a1e88566_720w.webp)

FFç®—æ³•é€šè¿‡å¢å¹¿è·¯å’Œåå‘è¾¹(ç›¸å½“äºä¸€ç§åæ‚”æœºåˆ¶)

### Ford-Fulkerson

```cpp
int n, m, s, t; // sæ˜¯æºç‚¹ï¼Œtæ˜¯æ±‡ç‚¹
bool vis[MAXN];
int dfs(int p = s, int flow = INF)
{
    if (p == t)
        return flow; // åˆ°è¾¾ç»ˆç‚¹ï¼Œè¿”å›è¿™æ¡å¢å¹¿è·¯çš„æµé‡
    vis[p] = true;
    for (int eg = head[p]; eg; eg = edges[eg].next)
    {
        int to = edges[eg].to, vol = edges[eg].w, c;
        // è¿”å›çš„æ¡ä»¶æ˜¯æ®‹ä½™å®¹é‡å¤§äº0ã€æœªè®¿é—®è¿‡è¯¥ç‚¹ä¸”æ¥ä¸‹æ¥å¯ä»¥è¾¾åˆ°ç»ˆç‚¹ï¼ˆé€’å½’åœ°å®ç°ï¼‰
        // ä¼ é€’ä¸‹å»çš„æµé‡æ˜¯è¾¹çš„å®¹é‡ä¸å½“å‰æµé‡ä¸­çš„è¾ƒå°å€¼
        if (vol > 0 && !vis[to] && (c = dfs(to, min(vol, flow))) != -1)
        {
            edges[eg].w -= c;
            edges[eg ^ 1].w += c;
            // è¿™æ˜¯é“¾å¼å‰å‘æ˜Ÿå–åå‘è¾¹çš„ä¸€ç§ç®€æ˜“çš„æ–¹æ³•
            // å»ºå›¾æ—¶è¦æŠŠcntç½®ä¸º1ï¼Œä¸”è¦ä¿è¯åå‘è¾¹ç´§æ¥ç€æ­£å‘è¾¹å»ºç«‹
            return c;
        }
    }
    return -1; // æ— æ³•åˆ°è¾¾ç»ˆç‚¹
}
inline int FF()
{
    int ans = 0, c;
    while ((c = dfs()) != -1)
    {
        memset(vis, 0, sizeof(vis));
        ans += c;
    }
    return ans;
}
```

### Edmond-Karp

```cpp
int n, m, s, t, last[MAXN], flow[MAXN];
inline int bfs()
{
    memset(last, -1, sizeof(last));
    queue<int> q;
    q.push(s);
    flow[s] = INF;
    while (!q.empty())
    {
        int p = q.front();
        q.pop();
        if (p == t) // åˆ°è¾¾æ±‡ç‚¹ï¼Œç»“æŸæœç´¢
            break;
        for (int eg = head[p]; eg; eg = edges[eg].next)
        {
            int to = edges[eg].to, vol = edges[eg].w;
            if (vol > 0 && last[to] == -1) // å¦‚æœæ®‹ä½™å®¹é‡å¤§äº0ä¸”æœªè®¿é—®è¿‡ï¼ˆæ‰€ä»¥lastä¿æŒåœ¨-1ï¼‰
            {
                last[to] = eg;
                flow[to] = min(flow[p], vol);
                q.push(to);
            }
        }
    }
    return last[t] != -1;
}
inline int EK()
{
    int maxflow = 0;
    while (bfs())
    {
        maxflow += flow[t];
        for (int i = t; i != s; i = edges[last[i] ^ 1].to) // ä»æ±‡ç‚¹åŸè·¯è¿”å›æ›´æ–°æ®‹ä½™å®¹é‡
        {
            edges[last[i]].w -= flow[t];
            edges[last[i] ^ 1].w += flow[t];
        }
    }
    return maxflow;
}
```

### Dinicç®—æ³•

```cpp
#include <bits/stdc++.h>
#define ll long long
#define int long long
using namespace std;
#define INF INT_MAX
const int N = 820010;
int head[N],cnt = 1;
struct node{
    ll next,w,to;
}edges[N<<1];
void add(int u,int v,int val){
    edges[++cnt].to = v;
    edges[cnt].w = val;
    edges[cnt].next = head[u];
    head[u] = cnt;
    edges[++cnt].to = u;
    edges[cnt].w=0;
    edges[cnt].next=head[v];
    head[v]=cnt;
}
int n, m, s, t, lv[N], cur[N]; // lvæ˜¯æ¯ä¸ªç‚¹çš„å±‚æ•°ï¼Œcurç”¨äºå½“å‰å¼§ä¼˜åŒ–æ ‡è®°å¢å¹¿èµ·ç‚¹
inline bool bfs() // BFSåˆ†å±‚
{
    memset(lv, -1, sizeof(lv));
    lv[s] = 0;
    memcpy(cur, head, sizeof(head)); // å½“å‰å¼§ä¼˜åŒ–åˆå§‹åŒ–
    queue<int> q;
    q.push(s);
    while (!q.empty())
    {
        int p = q.front();
        q.pop();
        for (int eg = head[p]; eg; eg = edges[eg].next)
        {
            int to = edges[eg].to, vol = edges[eg].w;
            if (vol > 0 && lv[to] == -1)
                lv[to] = lv[p] + 1, q.push(to);
        }
    }
    return lv[t] != -1; // å¦‚æœæ±‡ç‚¹æœªè®¿é—®è¿‡è¯´æ˜å·²ç»æ— æ³•è¾¾åˆ°æ±‡ç‚¹ï¼Œæ­¤æ—¶è¿”å›false
}
int dfs(int p = s, int flow = INF)
{
    if (p == t)
        return flow;
    int rmn = flow; // å‰©ä½™çš„æµé‡
    for (int eg = cur[p]; eg && rmn; eg = edges[eg].next) // å¦‚æœå·²ç»æ²¡æœ‰å‰©ä½™æµé‡åˆ™é€€å‡º
    {
        cur[p] = eg; // å½“å‰å¼§ä¼˜åŒ–ï¼Œæ›´æ–°å½“å‰å¼§
        int to = edges[eg].to, vol = edges[eg].w;
        if (vol > 0 && lv[to] == lv[p] + 1) // å¾€å±‚æ•°é«˜çš„æ–¹å‘å¢å¹¿
        {
            int c = dfs(to, min(vol, rmn)); // å°½å¯èƒ½å¤šåœ°ä¼ é€’æµé‡
            rmn -= c; // å‰©ä½™æµé‡å‡å°‘
            edges[eg].w -= c; // æ›´æ–°æ®‹ä½™å®¹é‡
            edges[eg ^ 1].w += c; // å†æ¬¡æé†’ï¼Œé“¾å¼å‰å‘æ˜Ÿçš„cntéœ€è¦åˆå§‹åŒ–ä¸º1ï¼ˆæˆ–-1ï¼‰æ‰èƒ½è¿™æ ·æ±‚åå‘è¾¹
        }
    }
    return flow - rmn; // è¿”å›ä¼ é€’å‡ºå»çš„æµé‡çš„å¤§å°
}
inline int dinic()
{
    int ans = 0;
    while (bfs())
        ans += dfs();
    return ans;
}
void solve(){
    cin >> n >> m >> s >> t;
    for(int i = 1;i <= m;i++){
        int u,v,val;
        cin >> u >> v >> val;
        add(u,v,val);
        add(v,u,0);
    }
    int ans = dinic();
    cout << ans << '\n';
}
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int T = 1;
    //cin >> T;
    while(T--){
        solve();
    }
}
```

## æœ€å°å‰²

ä¸€ä¸ªç½‘ç»œçš„å‰²æ˜¯è¿™æ ·ä¸€ä¸ªè¾¹é›†ï¼Œå¦‚æœæŠŠè¿™ä¸ªé›†åˆçš„è¾¹åˆ å»ï¼Œè¿™ä¸ªç½‘ç»œå°±ä¸å†è¿é€šï¼Œè¿™ä¸ªè¾¹é›†ä¸­è¾¹çš„å®¹é‡å’Œè¢«ç§°ä¸ºå‰²çš„å®¹é‡ï¼Œå®¹é‡æœ€å°çš„å‰²è¢«ç§°ä¸ºæœ€å°å‰²

#### æœ€å¤§æµæœ€å°å‰²å®šç†

å¯¹äºä¸€ä¸ªå®¹é‡ç½‘ç»œï¼Œå…¶æœ€å¤§æµç­‰äºæœ€å°å‰²çš„å®¹é‡

è®¡ç®—å‡ ä½•

- [äºŒç»´å‡ ä½•åŸºç¡€](#äºŒç»´å‡ ä½•åŸºç¡€)
- [åœ†å’Œçƒ](#åœ†å’Œçƒ)
- [æ¬§æ‹‰å››é¢ä½“å…¬å¼](#æ¬§æ‹‰å››é¢ä½“å…¬å¼)
- [æµ·ä¼¦å…¬å¼å½¢æ€çš„å››é¢ä½“ä½“ç§¯å…¬å¼](#æµ·ä¼¦å…¬å¼å½¢æ€çš„å››é¢ä½“ä½“ç§¯å…¬å¼)

äºŒç»´å‡ ä½•åŸºç¡€

```cpp
#include <iostream>
#include <cmath>
using namespace std;
#define eps 1e-10
/********** å®šä¹‰ç‚¹ **********/
struct Point{
    double x,y;
    Point(double x=0,double y=0):x(x),y(y) {}
};

/********** å®šä¹‰å‘é‡ **********/
typedef Point Vector;
/********** å‘é‡ + å‘é‡ = å‘é‡ **********/
Vector operator + (Vector a,Vector b)
{
    return Vector(a.x+b.x,a.y+b.y);
}
/********** ç‚¹ - ç‚¹ = å‘é‡ **********/
Vector operator - (Point a,Point b)    
{
    return Vector(a.x-b.x,a.y-b.y);
}
/********** å‘é‡ * æ•° = å‘é‡ **********/
Vector operator * (Vector a,double b)
{
    return Vector(a.x*b,a.y*b);
}
/********** å‘é‡ / æ•° = å‘é‡ **********/
Vector operator / (Vector a,double b)
{
    return Vector(a.x/b,a.y/b);
}
bool operator < (const Point& a,const Point& b)
{
    return a.x<b.x || (a.x==b.x && a.y<b.y);
}
int dcmp(double x)    //å‡å°‘ç²¾åº¦é—®é¢˜
{
    if(fabs(x)<eps)
        return 0;
    else 
        return x<0?-1:1;
}
bool operator == (const Point &a,const Point &b)    //åˆ¤æ–­ä¸¤ç‚¹æ˜¯å¦ç›¸ç­‰
{
    return dcmp(a.x-b.x)==0 && dcmp(a.y-b.y)==0;
}
/********** å‘é‡ç‚¹ç§¯ **********/
double Dot(Vector a,Vector b)
{
    return a.x*b.x+a.y*b.y;
}
/********** å‘é‡é•¿åº¦ **********/
double Length(Vector A)
{
    return sqrt(Dot(A,A));
}
/********** ä¸¤å‘é‡è§’åº¦ *********/
double Angle(Vector A,Vector B)
{
    return acos(Dot(A,B)/Length(A)/Length(B));
}

/********** 2å‘é‡æ±‚å‰ç§¯ **********/
double Cross(Vector a,Vector b)
{
    return a.x*b.y-b.x*a.y;
}
/********** 3ç‚¹æ±‚å‰ç§¯ **********/
double Cross(Point a,Point b,Point c)
{
    return (c.x-a.x)*(b.y-a.y) - (c.y-a.y)*(b.x-a.x);
}
/********** å‘é‡æ—‹è½¬ ***********/
Vector Rotate(Vector A,double rad)
{
    return Vector(A.x*cos(rad)-A.y*sin(rad),A.x*sin(rad)+A.y*cos(rad));
}
/********** å‘é‡çš„å•ä½æ³•çº¿ *********/
Vector Normal(Vector A)
{
    double L = Length(A);
    return Vector(-A.y/L,A.x/L);
}
/********** ç‚¹å’Œç›´çº¿ **********/
/********** æ±‚ä¸¤ç‚¹é—´è·ç¦» **********/
double dist(Point a,Point b)
{
    return sqrt( (a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y) );
}
/********** ç›´çº¿äº¤ç‚¹ **********/
Point GetLineIntersection(Point P,Vector v,Point Q,Vector w)
{
    Vector u = P-Q;
    double t = Cross(w,u) / Cross(v,w);
    return P+v*t;
}
/********** ç‚¹åˆ°ç›´çº¿çš„è·ç¦» ***********/
double DistanceToLine(Point P,Point A,Point B)
{
    Vector v1 = B-A,v2 = P-A;
    return fabs(Cross(v1,v2)) / Length(v1);    //å¦‚æœä¸å–ç»å¯¹å€¼ï¼Œå¾—åˆ°çš„æ˜¯æœ‰å‘è·ç¦»
}
/********** ç‚¹åˆ°çº¿æ®µçš„è·ç¦» **********/
double DistanceToSegment(Point P,Point A,Point B)
{
    if(A==B) return Length(P-A);
    Vector v1 = B-A,v2 = P-A,v3 = P-B;
    if(dcmp(Dot(v1,v2))<0) return Length(v2);
    else if(dcmp(Dot(v1,v3)) > 0) return Length(v3);
    else return fabs(Cross(v1,v2)) / Length(v1);
}
/********** ç‚¹åœ¨ç›´çº¿ä¸Šçš„æŠ•å½± ***********/
Point GetLineProjection(Point P,Point A,Point B)
{
    Vector v = B-A;
    return A+v*(Dot(v,P-A) / Dot(v,v));
}
/********** çº¿æ®µç›¸äº¤åˆ¤å®šï¼ˆè§„èŒƒç›¸äº¤ï¼‰ ************/
bool SegmentProperIntersection(Point a1,Point a2,Point b1,Point b2)
{
    double c1 = Cross(a2-a1,b1-a1),c2 = Cross(a2-a1,b2-a1),
           c3 = Cross(b2-b1,a1-b1),c4 = Cross(b2-b1,a2-b1);
    return dcmp(c1)*dcmp(c2)<0 && dcmp(c3)*dcmp(c4)<0;
}
/********* ç‚¹æ˜¯å¦åœ¨ä¸€æ¡çº¿æ®µä¸Š **********/
bool OnSegment(Point p,Point a1,Point a2)
{
    return dcmp(Cross(a1-p,a2-p)) == 0 && dcmp(Dot(a1-p,a2-p)) <0 ;
}
/*********    æ±‚å¤šè¾¹å½¢é¢ç§¯ **********/
double ConvexPolygonArea(Point* p,int n)
{
    double area = 0;
    for(int i=1;i<n-1;i++)
        area += Cross(p[i]-p[0],p[i+1]-p[0]);
    return area/2;
}



/********** åˆ¤æ–­ç‚¹æ˜¯å¦åœ¨å¤šè¾¹å½¢å†… **********/
//åˆ¤æ–­ç‚¹qæ˜¯å¦åœ¨å¤šè¾¹å½¢å†…
//ä»»æ„å‡¸æˆ–è€…å‡¹å¤šè¾¹å½¢
//é¡¶ç‚¹é›†åˆp[]æŒ‰é€†æ—¶é’ˆæˆ–è€…é¡ºæ—¶é’ˆé¡ºåºå­˜å‚¨(1..pointnum)
struct Point{
    double x,y;
};

struct Line{
    Point p1,p2;
};

double xmulti(Point p1,Point p2,Point p0)    //æ±‚p1p0å’Œp2p0çš„å‰ç§¯,å¦‚æœå¤§äº0,åˆ™p1åœ¨p2çš„é¡ºæ—¶é’ˆæ–¹å‘
{
    return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);
}
double Max(double a,double b)
{
    return a>b?a:b;
}
double Min(double a,double b)
{
    return a<b?a:b;
}
bool ponls(Point q,Line l)    //åˆ¤æ–­ç‚¹qæ˜¯å¦åœ¨çº¿æ®µlä¸Š
{
    if(q.x > Max(l.p1.x,l.p2.x) || q.x < Min(l.p1.x,l.p2.x)
            || q.y > Max(l.p1.y,l.p2.y) || q.y < Min(l.p1.y,l.p2.y) )
        return false;
    if(xmulti(l.p1,l.p2,q)==0)    //ç‚¹qä¸åœ¨lçš„å»¶é•¿çº¿æˆ–è€…åå‘å»¶é•¿çº¿ä¸Šï¼Œå¦‚æœå‰ç§¯å†ä¸º0ï¼Œåˆ™ç¡®å®šç‚¹qåœ¨çº¿æ®µlä¸Š
        return true;
    else
        return false;
}
bool pinplg(int pointnum,Point p[],Point q)
{
    Line s;
    int c = 0;
    for(int i=1;i<=pointnum;i++){    //å¤šè¾¹å½¢çš„æ¯æ¡è¾¹s
        if(i==pointnum)
            s.p1 = p[pointnum],s.p2 = p[1];
        else
            s.p1 = p[i],s.p2 = p[i+1];
        if(ponls(q,s))    //ç‚¹qåœ¨è¾¹sä¸Š
            return true;
        if(s.p1.y != s.p2.y){    //sä¸æ˜¯æ°´å¹³çš„
            Point t;
            t.x = q.x - 1,t.y = q.y;
            if( (s.p1.y == q.y && s.p1.x <=q.x) || (s.p2.y == q.y && s.p2.x <= q.x) ){    //sçš„ä¸€ä¸ªç«¯ç‚¹åœ¨Lä¸Š
                int tt;
                if(s.p1.y == q.y)
                    tt = 1;
                else if(s.p2.y == q.y)
                    tt = 2;
                int maxx;
                if(s.p1.y > s.p2.y)
                    maxx = 1;
                else
                    maxx = 2;
                if(tt == maxx) //å¦‚æœè¿™ä¸ªç«¯ç‚¹çš„çºµåæ ‡è¾ƒå¤§çš„é‚£ä¸ªç«¯ç‚¹
                    c++;
            }
            else if(xmulti(s.p1,t,q)*xmulti(s.p2,t,q) <= 0){    //Lå’Œè¾¹sç›¸äº¤
                Point lowp,higp;
                if(s.p1.y > s.p2.y)
                    lowp.x = s.p2.x,lowp.y = s.p2.y,higp.x = s.p1.x,higp.y = s.p1.y;
                else
                    lowp.x = s.p1.x,lowp.y = s.p1.y,higp.x = s.p2.x,higp.y = s.p2.y;
                if(xmulti(q,higp,lowp)>=0)
                    c++;
            }
        }
    }
    if(c%2==0)
        return false;
    else
        return true;
}
/********** æ±‚å‡¸åŒ… **********/
struct Point{
    double x,y;
};
double dis(Point p1,Point p2)
{
    return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));
}
double xmulti(Point p1,Point p2,Point p0)    //æ±‚p1p0å’Œp2p0çš„å‰ç§¯,å¦‚æœå¤§äº0,åˆ™p1åœ¨p2çš„é¡ºæ—¶é’ˆæ–¹å‘
{
    return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);
}
int graham(Point p[],int n,int pl[])    //ç‚¹é›†ï¼Œç‚¹çš„ä¸ªæ•°ï¼Œå‡¸åŒ…é¡¶ç‚¹é›†
{
    int pl[10005];
    //æ‰¾åˆ°çºµåæ ‡ï¼ˆyï¼‰æœ€å°çš„é‚£ä¸ªç‚¹ï¼Œä½œç¬¬ä¸€ä¸ªç‚¹ 
    int t = 1;
    for(int i=1;i<=n;i++)
        if(p[i].y < p[t].y)
            t = i;
    pl[1] = t;
    //é¡ºæ—¶é’ˆæ‰¾åˆ°å‡¸åŒ…ç‚¹çš„é¡ºåºï¼Œè®°å½•åœ¨ int pl[]
    int num = 1;    //å‡¸åŒ…ç‚¹çš„æ•°é‡
    do{    //å·²ç¡®å®šå‡¸åŒ…ä¸Šnumä¸ªç‚¹ 
        num++; //è¯¥ç¡®å®šç¬¬ num+1 ä¸ªç‚¹äº†
        t = pl[num-1]+1;
        if(t>n) t = 1;
        for(int i=1;i<=n;i++){    //æ ¸å¿ƒä»£ç ã€‚æ ¹æ®å‰ç§¯ç¡®å®šå‡¸åŒ…ä¸‹ä¸€ä¸ªç‚¹ã€‚ 
            double x = xmulti(p[i],p[t],p[pl[num-1]]);
            if(x<0) t = i;
        }
        pl[num] = t;
    } while(pl[num]!=pl[1]);
    return num-1;    //å‡¸åŒ…é¡¶ç‚¹æ•°
}
/********** æ±‚å‡¸åŒ…å‘¨é•¿ **********/
struct Point{
    double x,y;
};
double dis(Point p1,Point p2)
{
    return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));
}
double xmulti(Point p1,Point p2,Point p0)    //æ±‚p1p0å’Œp2p0çš„å‰ç§¯,å¦‚æœå¤§äº0,åˆ™p1åœ¨p2çš„é¡ºæ—¶é’ˆæ–¹å‘
{
    return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);
}
double graham(Point p[],int n)    //ç‚¹é›†å’Œç‚¹çš„ä¸ªæ•° 
{
    int pl[10005];
    //æ‰¾åˆ°çºµåæ ‡ï¼ˆyï¼‰æœ€å°çš„é‚£ä¸ªç‚¹ï¼Œä½œç¬¬ä¸€ä¸ªç‚¹ 
    int t = 1;
    for(int i=1;i<=n;i++)
        if(p[i].y < p[t].y)
            t = i;
    pl[1] = t;
    //é¡ºæ—¶é’ˆæ‰¾åˆ°å‡¸åŒ…ç‚¹çš„é¡ºåºï¼Œè®°å½•åœ¨ int pl[]
    int num = 1;    //å‡¸åŒ…ç‚¹çš„æ•°é‡
    do{    //å·²ç¡®å®šå‡¸åŒ…ä¸Šnumä¸ªç‚¹ 
        num++; //è¯¥ç¡®å®šç¬¬ num+1 ä¸ªç‚¹äº†
        t = pl[num-1]+1;
        if(t>n) t = 1;
        for(int i=1;i<=n;i++){    //æ ¸å¿ƒä»£ç ã€‚æ ¹æ®å‰ç§¯ç¡®å®šå‡¸åŒ…ä¸‹ä¸€ä¸ªç‚¹ã€‚ 
            double x = xmulti(p[i],p[t],p[pl[num-1]]);
            if(x<0) t = i;
        }
        pl[num] = t;
    } while(pl[num]!=pl[1]);
    //è®¡ç®—å‡¸åŒ…å‘¨é•¿ 
    double sum = 0;
    for(int i=1;i<num;i++)
        sum += dis(p[pl[i]],p[pl[i+1]]);
    return sum;
}
/********** æ±‚å¤šè¾¹å½¢é¢ç§¯ **********/
struct Point{    //å®šä¹‰ç‚¹ç»“æ„ 
    double x,y;
};
double getS(Point a,Point b,Point c)    //è¿”å›ä¸‰è§’å½¢é¢ç§¯ 
{  
    return ((b.x - a.x) * (c.y - a.y) - (b.y - a.y)*(c.x - a.x))/2;  
}
double getPS(Point p[],int n)    //è¿”å›å¤šè¾¹å½¢é¢ç§¯ã€‚å¿…é¡»ç¡®ä¿ n>=3ï¼Œä¸”å¤šè¾¹å½¢æ˜¯å‡¸å¤šè¾¹å½¢ 
{
    double sumS=0;
    for(int i=1;i<=n-1;i++)
        sumS+=getS(p[1],p[i],p[i+1]);
    return sumS;
}
```

# è®¡ç®—å‡ ä½•

## äºŒç»´å‡ ä½•åŸºç¡€

```cpp
  |     è®¡ç®—å‡ ä½•åŸºç¡€å‡½æ•°     |
  | 1.ç‚¹å’Œå‘é‡çš„å®šä¹‰         |
  | 2.å‘é‡çš„åŸºæœ¬è¿ç®—         |
  | 3.ç‚¹ç§¯                   |
  | 4.å‘é‡é•¿åº¦               |
  | 5.ä¸¤å‘é‡è§’åº¦             |
  | 6.å‰ç§¯ï¼ˆ2å‘é‡/3ç‚¹ï¼‰      |
  | 7.å‘é‡æ—‹è½¬               |
  | 8.å‘é‡çš„å•ä½æ³•çº¿         |
  | 9.æ±‚ä¸¤ç‚¹è·ç¦»             |
  | 10.ç›´çº¿ï¼ˆå°„çº¿ï¼‰äº¤ç‚¹      |
  | 11.ç‚¹åˆ°ç›´çº¿çš„è·ç¦»        |
  | 12.ç‚¹åˆ°çº¿æ®µçš„è·ç¦»        |
  | 13.ç‚¹åœ¨ç›´çº¿ä¸Šçš„æŠ•å½±      |
  | 14.çº¿æ®µç›¸äº¤åˆ¤å®š(è§„èŒƒç›¸äº¤)|
  | 15.ç‚¹æ˜¯å¦åœ¨ä¸€æ¡çº¿æ®µä¸Š    |
  | 16.æ±‚å¤šè¾¹å½¢é¢ç§¯          |
  | 17.åˆ¤æ–­ç‚¹æ˜¯å¦åœ¨å¤šè¾¹å½¢å†…  |
  | 18.æ±‚å‡¸åŒ…                |
  | 19.æ±‚å‡¸åŒ…å‘¨é•¿            |
  | 20.æ±‚å¤šè¾¹å½¢é¢ç§¯          |
#include <iostream>
#include <cmath>
using namespace std;
#define eps 1e-10
/********** å®šä¹‰ç‚¹ **********/
struct Point{
    double x,y;
    Point(double x=0,double y=0):x(x),y(y) {}
};

/********** å®šä¹‰å‘é‡ **********/
typedef Point Vector;
/********** å‘é‡ + å‘é‡ = å‘é‡ **********/
Vector operator + (Vector a,Vector b)
{
    return Vector(a.x+b.x,a.y+b.y);
}
/********** ç‚¹ - ç‚¹ = å‘é‡ **********/
Vector operator - (Point a,Point b)    
{
    return Vector(a.x-b.x,a.y-b.y);
}
/********** å‘é‡ * æ•° = å‘é‡ **********/
Vector operator * (Vector a,double b)
{
    return Vector(a.x*b,a.y*b);
}
/********** å‘é‡ / æ•° = å‘é‡ **********/
Vector operator / (Vector a,double b)
{
    return Vector(a.x/b,a.y/b);
}
bool operator < (const Point& a,const Point& b)
{
    return a.x<b.x || (a.x==b.x && a.y<b.y);
}
int dcmp(double x)    //å‡å°‘ç²¾åº¦é—®é¢˜
{
    if(fabs(x)<eps)
        return 0;
    else 
        return x<0?-1:1;
}
bool operator == (const Point &a,const Point &b)    //åˆ¤æ–­ä¸¤ç‚¹æ˜¯å¦ç›¸ç­‰
{
    return dcmp(a.x-b.x)==0 && dcmp(a.y-b.y)==0;
}
/********** å‘é‡ç‚¹ç§¯ **********/
double Dot(Vector a,Vector b)
{
    return a.x*b.x+a.y*b.y;
}
/********** å‘é‡é•¿åº¦ **********/
double Length(Vector A)
{
    return sqrt(Dot(A,A));
}
/********** ä¸¤å‘é‡è§’åº¦ *********/
double Angle(Vector A,Vector B)
{
    return acos(Dot(A,B)/Length(A)/Length(B));
}

/********** 2å‘é‡æ±‚å‰ç§¯ **********/
double Cross(Vector a,Vector b)
{
    return a.x*b.y-b.x*a.y;
}
/********** 3ç‚¹æ±‚å‰ç§¯ **********/
double Cross(Point a,Point b,Point c)
{
    return (c.x-a.x)*(b.y-a.y) - (c.y-a.y)*(b.x-a.x);
}
/********** å‘é‡æ—‹è½¬ ***********/
Vector Rotate(Vector A,double rad)
{
    return Vector(A.x*cos(rad)-A.y*sin(rad),A.x*sin(rad)+A.y*cos(rad));
}
/********** å‘é‡çš„å•ä½æ³•çº¿ *********/
Vector Normal(Vector A)
{
    double L = Length(A);
    return Vector(-A.y/L,A.x/L);
}
/********** ç‚¹å’Œç›´çº¿ **********/
/********** æ±‚ä¸¤ç‚¹é—´è·ç¦» **********/
double dist(Point a,Point b)
{
    return sqrt( (a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y) );
}
/********** ç›´çº¿äº¤ç‚¹ **********/
Point GetLineIntersection(Point P,Vector v,Point Q,Vector w)
{
    Vector u = P-Q;
    double t = Cross(w,u) / Cross(v,w);
    return P+v*t;
}
/********** ç‚¹åˆ°ç›´çº¿çš„è·ç¦» ***********/
double DistanceToLine(Point P,Point A,Point B)
{
    Vector v1 = B-A,v2 = P-A;
    return fabs(Cross(v1,v2)) / Length(v1);    //å¦‚æœä¸å–ç»å¯¹å€¼ï¼Œå¾—åˆ°çš„æ˜¯æœ‰å‘è·ç¦»
}
/********** ç‚¹åˆ°çº¿æ®µçš„è·ç¦» **********/
double DistanceToSegment(Point P,Point A,Point B)
{
    if(A==B) return Length(P-A);
    Vector v1 = B-A,v2 = P-A,v3 = P-B;
    if(dcmp(Dot(v1,v2))<0) return Length(v2);
    else if(dcmp(Dot(v1,v3)) > 0) return Length(v3);
    else return fabs(Cross(v1,v2)) / Length(v1);
}
/********** ç‚¹åœ¨ç›´çº¿ä¸Šçš„æŠ•å½± ***********/
Point GetLineProjection(Point P,Point A,Point B)
{
    Vector v = B-A;
    return A+v*(Dot(v,P-A) / Dot(v,v));
}
/********** çº¿æ®µç›¸äº¤åˆ¤å®šï¼ˆè§„èŒƒç›¸äº¤ï¼‰ ************/
bool SegmentProperIntersection(Point a1,Point a2,Point b1,Point b2)
{
    double c1 = Cross(a2-a1,b1-a1),c2 = Cross(a2-a1,b2-a1),
           c3 = Cross(b2-b1,a1-b1),c4 = Cross(b2-b1,a2-b1);
    return dcmp(c1)*dcmp(c2)<0 && dcmp(c3)*dcmp(c4)<0;
}
/********* ç‚¹æ˜¯å¦åœ¨ä¸€æ¡çº¿æ®µä¸Š **********/
bool OnSegment(Point p,Point a1,Point a2)
{
    return dcmp(Cross(a1-p,a2-p)) == 0 && dcmp(Dot(a1-p,a2-p)) <0 ;
}
/*********    æ±‚å¤šè¾¹å½¢é¢ç§¯ **********/
double ConvexPolygonArea(Point* p,int n)
{
    double area = 0;
    for(int i=1;i<n-1;i++)
        area += Cross(p[i]-p[0],p[i+1]-p[0]);
    return area/2;
}



/********** åˆ¤æ–­ç‚¹æ˜¯å¦åœ¨å¤šè¾¹å½¢å†… **********/
//åˆ¤æ–­ç‚¹qæ˜¯å¦åœ¨å¤šè¾¹å½¢å†…
//ä»»æ„å‡¸æˆ–è€…å‡¹å¤šè¾¹å½¢
//é¡¶ç‚¹é›†åˆp[]æŒ‰é€†æ—¶é’ˆæˆ–è€…é¡ºæ—¶é’ˆé¡ºåºå­˜å‚¨(1..pointnum)
struct Point{
    double x,y;
};

struct Line{
    Point p1,p2;
};

double xmulti(Point p1,Point p2,Point p0)    //æ±‚p1p0å’Œp2p0çš„å‰ç§¯,å¦‚æœå¤§äº0,åˆ™p1åœ¨p2çš„é¡ºæ—¶é’ˆæ–¹å‘
{
    return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);
}
double Max(double a,double b)
{
    return a>b?a:b;
}
double Min(double a,double b)
{
    return a<b?a:b;
}
bool ponls(Point q,Line l)    //åˆ¤æ–­ç‚¹qæ˜¯å¦åœ¨çº¿æ®µlä¸Š
{
    if(q.x > Max(l.p1.x,l.p2.x) || q.x < Min(l.p1.x,l.p2.x)
            || q.y > Max(l.p1.y,l.p2.y) || q.y < Min(l.p1.y,l.p2.y) )
        return false;
    if(xmulti(l.p1,l.p2,q)==0)    //ç‚¹qä¸åœ¨lçš„å»¶é•¿çº¿æˆ–è€…åå‘å»¶é•¿çº¿ä¸Šï¼Œå¦‚æœå‰ç§¯å†ä¸º0ï¼Œåˆ™ç¡®å®šç‚¹qåœ¨çº¿æ®µlä¸Š
        return true;
    else
        return false;
}
bool pinplg(int pointnum,Point p[],Point q)
{
    Line s;
    int c = 0;
    for(int i=1;i<=pointnum;i++){    //å¤šè¾¹å½¢çš„æ¯æ¡è¾¹s
        if(i==pointnum)
            s.p1 = p[pointnum],s.p2 = p[1];
        else
            s.p1 = p[i],s.p2 = p[i+1];
        if(ponls(q,s))    //ç‚¹qåœ¨è¾¹sä¸Š
            return true;
        if(s.p1.y != s.p2.y){    //sä¸æ˜¯æ°´å¹³çš„
            Point t;
            t.x = q.x - 1,t.y = q.y;
            if( (s.p1.y == q.y && s.p1.x <=q.x) || (s.p2.y == q.y && s.p2.x <= q.x) ){    //sçš„ä¸€ä¸ªç«¯ç‚¹åœ¨Lä¸Š
                int tt;
                if(s.p1.y == q.y)
                    tt = 1;
                else if(s.p2.y == q.y)
                    tt = 2;
                int maxx;
                if(s.p1.y > s.p2.y)
                    maxx = 1;
                else
                    maxx = 2;
                if(tt == maxx) //å¦‚æœè¿™ä¸ªç«¯ç‚¹çš„çºµåæ ‡è¾ƒå¤§çš„é‚£ä¸ªç«¯ç‚¹
                    c++;
            }
            else if(xmulti(s.p1,t,q)*xmulti(s.p2,t,q) <= 0){    //Lå’Œè¾¹sç›¸äº¤
                Point lowp,higp;
                if(s.p1.y > s.p2.y)
                    lowp.x = s.p2.x,lowp.y = s.p2.y,higp.x = s.p1.x,higp.y = s.p1.y;
                else
                    lowp.x = s.p1.x,lowp.y = s.p1.y,higp.x = s.p2.x,higp.y = s.p2.y;
                if(xmulti(q,higp,lowp)>=0)
                    c++;
            }
        }
    }
    if(c%2==0)
        return false;
    else
        return true;
}
/********** æ±‚å‡¸åŒ… **********/
struct Point{
    double x,y;
};
double dis(Point p1,Point p2)
{
    return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));
}
double xmulti(Point p1,Point p2,Point p0)    //æ±‚p1p0å’Œp2p0çš„å‰ç§¯,å¦‚æœå¤§äº0,åˆ™p1åœ¨p2çš„é¡ºæ—¶é’ˆæ–¹å‘
{
    return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);
}
int graham(Point p[],int n,int pl[])    //ç‚¹é›†ï¼Œç‚¹çš„ä¸ªæ•°ï¼Œå‡¸åŒ…é¡¶ç‚¹é›†
{
    int pl[10005];
    //æ‰¾åˆ°çºµåæ ‡ï¼ˆyï¼‰æœ€å°çš„é‚£ä¸ªç‚¹ï¼Œä½œç¬¬ä¸€ä¸ªç‚¹ 
    int t = 1;
    for(int i=1;i<=n;i++)
        if(p[i].y < p[t].y)
            t = i;
    pl[1] = t;
    //é¡ºæ—¶é’ˆæ‰¾åˆ°å‡¸åŒ…ç‚¹çš„é¡ºåºï¼Œè®°å½•åœ¨ int pl[]
    int num = 1;    //å‡¸åŒ…ç‚¹çš„æ•°é‡
    do{    //å·²ç¡®å®šå‡¸åŒ…ä¸Šnumä¸ªç‚¹ 
        num++; //è¯¥ç¡®å®šç¬¬ num+1 ä¸ªç‚¹äº†
        t = pl[num-1]+1;
        if(t>n) t = 1;
        for(int i=1;i<=n;i++){    //æ ¸å¿ƒä»£ç ã€‚æ ¹æ®å‰ç§¯ç¡®å®šå‡¸åŒ…ä¸‹ä¸€ä¸ªç‚¹ã€‚ 
            double x = xmulti(p[i],p[t],p[pl[num-1]]);
            if(x<0) t = i;
        }
        pl[num] = t;
    } while(pl[num]!=pl[1]);
    return num-1;    //å‡¸åŒ…é¡¶ç‚¹æ•°
}
/********** æ±‚å‡¸åŒ…å‘¨é•¿ **********/
struct Point{
    double x,y;
};
double dis(Point p1,Point p2)
{
    return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));
}
double xmulti(Point p1,Point p2,Point p0)    //æ±‚p1p0å’Œp2p0çš„å‰ç§¯,å¦‚æœå¤§äº0,åˆ™p1åœ¨p2çš„é¡ºæ—¶é’ˆæ–¹å‘
{
    return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);
}
double graham(Point p[],int n)    //ç‚¹é›†å’Œç‚¹çš„ä¸ªæ•° 
{
    int pl[10005];
    //æ‰¾åˆ°çºµåæ ‡ï¼ˆyï¼‰æœ€å°çš„é‚£ä¸ªç‚¹ï¼Œä½œç¬¬ä¸€ä¸ªç‚¹ 
    int t = 1;
    for(int i=1;i<=n;i++)
        if(p[i].y < p[t].y)
            t = i;
    pl[1] = t;
    //é¡ºæ—¶é’ˆæ‰¾åˆ°å‡¸åŒ…ç‚¹çš„é¡ºåºï¼Œè®°å½•åœ¨ int pl[]
    int num = 1;    //å‡¸åŒ…ç‚¹çš„æ•°é‡
    do{    //å·²ç¡®å®šå‡¸åŒ…ä¸Šnumä¸ªç‚¹ 
        num++; //è¯¥ç¡®å®šç¬¬ num+1 ä¸ªç‚¹äº†
        t = pl[num-1]+1;
        if(t>n) t = 1;
        for(int i=1;i<=n;i++){    //æ ¸å¿ƒä»£ç ã€‚æ ¹æ®å‰ç§¯ç¡®å®šå‡¸åŒ…ä¸‹ä¸€ä¸ªç‚¹ã€‚ 
            double x = xmulti(p[i],p[t],p[pl[num-1]]);
            if(x<0) t = i;
        }
        pl[num] = t;
    } while(pl[num]!=pl[1]);
    //è®¡ç®—å‡¸åŒ…å‘¨é•¿ 
    double sum = 0;
    for(int i=1;i<num;i++)
        sum += dis(p[pl[i]],p[pl[i+1]]);
    return sum;
}
/********** æ±‚å¤šè¾¹å½¢é¢ç§¯ **********/
struct Point{    //å®šä¹‰ç‚¹ç»“æ„ 
    double x,y;
};
double getS(Point a,Point b,Point c)    //è¿”å›ä¸‰è§’å½¢é¢ç§¯ 
{  
    return ((b.x - a.x) * (c.y - a.y) - (b.y - a.y)*(c.x - a.x))/2;  
}
double getPS(Point p[],int n)    //è¿”å›å¤šè¾¹å½¢é¢ç§¯ã€‚å¿…é¡»ç¡®ä¿ n>=3ï¼Œä¸”å¤šè¾¹å½¢æ˜¯å‡¸å¤šè¾¹å½¢ 
{
    double sumS=0;
    for(int i=1;i<=n-1;i++)
        sumS+=getS(p[1],p[i],p[i+1]);
    return sumS;
}
```



åœ†å’Œçƒ
---

```cpp
#include <iostream>
#include <cmath>
using namespace std;
#define eps 1e-10
/********** å®šä¹‰ç‚¹ **********/
struct Point{
    double x,y;
    Point(double x=0,double y=0):x(x),y(y) {}
};
/********** å®šä¹‰ä¸‰ç»´ç‚¹ ***********/
struct Point3{
    double x,y,z;
    Point3(double x=0,double y=0,double z=0):x(x),y(y),z(z) {}
};
/********** å®šä¹‰åœ† **********/
struct Circle{
    Point c;
    double r;
    Circle(Point c,double r):c(c),r(r){}
    Point point(double a){
        return Point(c.x + cos(a)*r,c.y + sin(a)*r);
    }
};
/*********** ä¸‰ç»´ç‚¹è·ç¦» **********/
double dis3(Point3 A,Point3 B)
{
    return sqrt((A.x-B.x)*(A.x-B.x)+(A.y-B.y)*(A.y-B.y)+(A.z-B.z)*(A.z-B.z));
}
/*********** çƒé¢ ***********/
/*********** è§’åº¦è½¬æ¢æˆå¼§åº¦ ***********/
double torad(double deg)
{
    return deg/180 * acos(-1);    //acos(-1)å°±æ˜¯PI
}
/*********** ç»çº¬åº¦ï¼ˆè§’åº¦ï¼‰è½¬åŒ–ä¸ºç©ºé—´åæ ‡ **********/
void get_coord(double R,double lat,double lng,double &x ,double &y,double &z)
{
    lat = torad(lat);    //çº¬åº¦
    lng = torad(lng);    //ç»åº¦
    x = R*cos(lat)*cos(lng);
    y = R*cos(lat)*sin(lng);
    z = R*sin(lat);
}
/*********** ä¸¤ç‚¹çš„çƒé¢è·ç¦» ***********/s
double disA2B(double R,Point3 A,Point3 B)
{
    //å°†çƒé¢è·ç¦»çœ‹æˆæ±‚ç‚¹Aï¼ŒBå’ŒåŠå¾„Ræ„æˆçš„æ‰‡å½¢çš„å¼§é•¿
    double d = dis3(A,B);    //å¼¦é•¿
    double a = 2*asin(d/2/R);    //åœ†å¿ƒè§’
    double l = a*R;        //å¼§é•¿
    return l;
}

```

æ¬§æ‹‰å››é¢ä½“å…¬å¼
---

**å¼•ç”¨å£°æ˜ï¼Œæ¥è‡ªï¼šhttp://blog.csdn.net/archibaldyangfan/article/details/8035332**

1ï¼Œå»ºç«‹xï¼Œyï¼Œzç›´è§’åæ ‡ç³»ã€‚è®¾Aã€Bã€Cå°‘æ‹¿ç‚¹çš„åæ ‡åˆ†åˆ«ä¸º(a1,b,1,c1),(a2,b2,c2),(a3,b3,c3),å››é¢ä½“O-ABCçš„å…­æ¡æ£±é•¿åˆ†åˆ«ä¸ºlï¼Œmï¼Œnï¼Œpï¼Œqï¼Œrï¼›

![](http://pic002.cnblogs.com/images/2012/168787/2012071315214513.png)

2ï¼Œå››é¢ä½“çš„ä½“ç§¯ä¸ºï¼Œç”±äºç°åœ¨ä¸çŸ¥é“å‘é‡æ€ä¹ˆæ‰“å‡ºæ¥ï¼Œæˆ‘å°±æ’å¼ å›¾ç‰‡äº†ï¼Œ

![](http://pic002.cnblogs.com/images/2012/168787/2012071315220185.png)

å°†è¿™ä¸ªå¼å­å¹³æ–¹åå¾—åˆ°ï¼š

![](http://pic002.cnblogs.com/images/2012/168787/2012071315221363.png)

3ï¼Œæ ¹æ®çŸ¢é‡æ•°é‡ç§¯çš„åæ ‡è¡¨è¾¾å¼åŠæ•°é‡ç§¯çš„å®šä¹‰å¾—

![](http://pic002.cnblogs.com/images/2012/168787/2012071315222945.png)

åˆæ ¹æ®ä½™å¼¦å®šç†å¾—

![](http://pic002.cnblogs.com/images/2012/168787/2012071315223785.png)

4ï¼Œå°†ä¸Šè¿°çš„å¼å­å¸¦å…¥ï¼ˆ1ï¼‰ï¼Œå°±å¾—åˆ°äº†ä¼ è¯´ä¸­çš„æ¬§æ‹‰å››é¢ä½“å…¬å¼

![](http://pic002.cnblogs.com/images/2012/168787/2012071315224795.png)

æµ·ä¼¦å…¬å¼å½¢æ€çš„å››é¢ä½“ä½“ç§¯å…¬å¼
---

ä¸€èˆ¬æµ·ä¼¦å…¬å¼ï¼šå…¬å¼ä¸­aï¼Œbï¼Œcåˆ†åˆ«ä¸ºä¸‰è§’å½¢ä¸‰è¾¹é•¿ï¼Œpä¸ºåŠå‘¨é•¿ï¼ŒSä¸ºä¸‰è§’å½¢çš„é¢ç§¯ã€‚

![](https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=3652749987,823871558&fm=58)

ä»¥ä¸‹å†…å®¹è½¬è‡ªç»´åŸºç™¾ç§‘

å¦‚æœUã€Vã€Wã€uã€vã€wæ˜¯å››é¢ä½“çš„å…­æ¡è¾¹é•¿ï¼ˆUã€Vã€Wæ„æˆå››é¢ä½“çš„å…¶ä¸­ä¸€ä¸ªä¸‰è§’å½¢é¢ï¼Œè€Œuæ˜¯ä¸Uç›¸å¯¹çš„æ£±ï¼Œvæ˜¯ä¸Vç›¸å¯¹çš„æ£±ï¼Œwæ˜¯ä¸Wç›¸å¯¹çš„æ£±ï¼‰ï¼Œåˆ™å››é¢ä½“ä½“ç§¯

![](https://wikimedia.org/api/rest_v1/media/math/render/svg/f94edcc3b88658fb9156e98f9e9d9ed3048b512e)

è¿™é‡Œ

![](https://wikimedia.org/api/rest_v1/media/math/render/svg/b8c253da79d2082f826ade67c38a809662fe95d2)





â€‹	
